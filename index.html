<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>팀 매칭 & 점수 관리</title>
    <style>
        :root {
            --bg: #0b0f14;
            --panel: #111826;
            --muted: #8aa0b8;
            --text: #e6eef8;
            --acc: #4da3ff;
            --acc2: #22c55e;
            --warn: #ef4444;
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            font-family: Inter, Pretendard, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif;
            background: linear-gradient(180deg, #09111a, #0b0f14 30%, #0f172a);
            color: var(--text)
        }

        .wrap {
            margin: 28px auto;
            padding: 20px
        }

        h1 {
            font-size: 22px;
            margin: 0 0 14px;
            letter-spacing: .2px;
            display: flex;
            gap: 10px;
            align-items: center
        }

        .bar {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 14px;
            margin-bottom: 14px;
        }

        .btn {
            border: none;
            border-radius: 12px;
            padding: 10px 14px;
            font-weight: 600;
            background: #1e293b;
            color: #dbe7f8;
            cursor: pointer;
            transition: .15s
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(77, 163, 255, .15)
        }

        .btn.primary {
            background: var(--acc);
            color: #031427
        }

        .btn.success {
            background: var(--acc2);
            color: #06220f
        }

        .btn.warn {
            background: var(--warn)
        }

        .btn.ghost {
            background: #0b1220;
            color: #9db7d9;
            border: 1px solid #20304a
        }

        .btn.small {
            padding: 6px 10px;
            border-radius: 10px
        }

        /* ===== Layout ===== */
        .grid {
            display: grid;
            grid-template-columns: minmax(0, 0.7fr) minmax(500px, 1fr);
            gap: 14px;
            min-width: 0;
        }

        @media (max-width: 980px) {
            .grid {
                grid-template-columns: 1fr
            }
        }

        .panel {
            min-width: 0;
            overflow-x: hidden;
        }

        .panel .hd {
            padding: 12px 14px;
            border-bottom: 1px solid #1c2b45;
            display: flex;
            align-items: center;
            justify-content: space-between
        }

        .panel .hd .title {
            font-weight: 800;
            font-size: 14px;
            letter-spacing: .6px;
            text-transform: uppercase;
            color: #a9c3e6
        }

        .panel .bd {
            padding: 14px
        }

        .muted {
            color: var(--muted)
        }

        input[type="text"],
        input[type="number"] {
            background: #0a1220;
            border: 1px solid #233656;
            color: #e6eef8;
            border-radius: 10px;
            padding: 9px 11px
        }

        input[type="file"] {
            color: #9bb3cf
        }

        .team {
            border: 1px dashed #2a4168;
            border-radius: 14px;
            padding: 12px;
            background: linear-gradient(180deg, #0c1626, #0c1422);
            min-width: 0;
            position: relative;
        }

        .confetti-canvas {
            position: absolute;
            inset: 0;
            /* top/right/bottom/left: 0 */
            pointer-events: none;
        }

        .team h3 {
            margin: 0 0 8px;
            font-size: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center
        }

        .team ul {
            list-style: none;
            margin: 0;
            padding: 4px 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: 263px;
            overflow-y: auto;
            overflow-x: hidden;
            scrollbar-gutter: stable both-edges;
            padding-right: 6px;
        }

        /* 팀 행 */
        .teamRow {
            display: grid;
            grid-template-columns: minmax(12ch, 1fr) 8ch 6ch 14ch;
            gap: 8px;
            padding: 10px 14px;
            background: #0e1a2a;
            border: 1px solid #1f2e47;
            border-radius: 12px;
            align-items: center;
        }

        .teamRow:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 18px rgba(0, 0, 0, .25);
            transition: .15s;
        }

        .teamRow .cell-name {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            white-space: normal;
            text-overflow: unset;
            line-height: 1.3;
            text-align: center;
        }

        .teamRow .cell-line {
            text-align: center;
            opacity: .9
        }

        .teamRow .cell-wr {
            text-align: center
        }

        .teamRow .cell-score {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }

        .tabnum {
            font-variant-numeric: tabular-nums;
            font-feature-settings: "tnum" 1;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
                "Liberation Mono", "Courier New", monospace;
        }

        .avg {
            font-weight: 800
        }

        .avg .good {
            color: var(--acc2)
        }

        .avg .bad {
            color: #f59e0b
        }

        .winbar {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
            min-width: 0
        }

        .winbar-left {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            flex: 1 1 auto;
            min-width: 0;
        }

        .winbar-right {
            margin-left: auto;
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        @media (max-width:640px) {
            .winbar .wins {
                margin-left: 0;
            }
        }

        .winbar .wins {
            margin-left: auto;
            display: flex;
            gap: 8px;
        }

        .winbar label {
            align-items: center;
            gap: 6px;
        }

        .winbar label input {
            width: 80px;
            max-width: 80px
        }

        .winbar label select {
            max-width: 180px
        }

        .winbar .btn.success {
            min-width: 108px;
            white-space: nowrap;
            flex: 0 0 auto
        }

        .winbar .btn.ghost {
            white-space: nowrap
        }

        .teamControls {
            display: flex;
            gap: 8px;
            align-items: center;
            margin: 8px 0 12px
        }

        /* ===== Roster ===== */
        .rosterTable {
            border: 1px solid #1c2b45;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 10px
        }

        .rhead,
        .rbody {
            width: 100%;
            table-layout: fixed;
            border-collapse: separate;
            border-spacing: 0 8px
        }

        .rhead thead th {
            font-size: 12px;
            color: #8fb1d6;
            font-weight: 700;
            text-align: center;
            padding: 8px;
            background: #0c1422
        }

        .rscroll {
            max-height: 440px;
            overflow-y: auto;
            overflow-x: hidden;
            background: transparent;
            padding: 6px
        }

        .rbody tbody tr {
            background: #0b1422;
            border: 1px solid #1c2b45;
        }

        .rbody tbody tr td {
            padding: 10px 8px;
            text-align: center
        }

        .rbody tbody tr td:first-child {
            border-top-left-radius: 12px;
            border-bottom-left-radius: 12px
        }

        .rbody tbody tr td:last-child {
            border-top-right-radius: 12px;
            border-bottom-right-radius: 12px
        }

        .rbody .cell-name,
        .rhead th:nth-child(2) {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 12ch;
            text-align: center
        }

        .cell-line {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px
        }

        .cell-score .score-num {
            display: inline-block;
            width: 8ch;
            text-align: right;
        }

        .cell-score .delta {
            display: inline-block;
            min-width: 5ch;
            text-align: right;
        }

        .line-select {
            width: 54px;
            height: 30px;
            background: #0a1220;
            border: 1px solid #233656;
            color: #e6eef8;
            border-radius: 8px;
            appearance: none;
            text-align: center
        }

        .rscroll input.cell-score,
        .rscroll input.cell-games {
            width: 100% !important;
            max-width: 100%;
            box-sizing: border-box
        }

        .wl-badge,
        .wr-badge {
            font-size: 14px;
            opacity: .85
        }

        .wr-good {
            color: var(--acc2)
        }

        .wr-bad {
            color: var(--warn)
        }

        select {
            max-width: 180px !important;
            background: #0a1220;
            border: 1px solid #233656;
            color: #e6eef8;
            border-radius: 10px;
            height: 34px;
            padding: 0 10px;
            appearance: none;
        }

        .listbar.manage {
            display: grid;
            grid-template-columns: minmax(180px, 1fr) 120px repeat(2, auto) auto auto;
            gap: 8px 12px;
            align-items: center;
        }

        @media (max-width: 1100px) {
            .listbar.manage {
                grid-template-columns: minmax(160px, 1fr) 110px auto auto;
            }
        }

        .listbar.manage #scoreInput {
            width: 110px !important;
        }

        #linePrimaryInput,
        #lineSecondaryInput {
            width: 80px;
            height: 28px;
            font-size: 12px;
        }

        .listbar.manage label[for="rosterSort"],
        .listbar.manage select#rosterSort {
            justify-self: end;
        }

        /* 검색어 하이라이트 */
        mark {
            background: rgba(77, 163, 255, .25);
            padding: 0 2px;
            border-radius: 3px;
        }

        #managePanel.dragover {
            outline: 2px dashed var(--acc);
            outline-offset: -6px;
            box-shadow: 0 0 0 3px rgba(77, 163, 255, .12) inset;
            background-image: linear-gradient(180deg, rgba(77, 163, 255, .06), transparent);
        }

        .rhead thead th.sortable {
            cursor: pointer;
            user-select: none;
            position: relative;
        }

        .sort-ind {
            font-weight: 800;
            margin-left: 4px;
            opacity: .9;
        }

        /* === Thin Footer - centered & 3-line layout === */
        .site-footer {
            background: #0b1220;
            border-top: 1px solid #1c2b45;
            color: #9bb3cf;
            font-size: 12px;
        }

        .site-footer .inner {
            max-width: 1100px;
            margin: 0 auto;
            padding: 10px 14px;
            display: flex;
            flex-direction: column;
            /* 세로 스택 */
            align-items: center;
            /* 가로 가운데 */
            gap: 6px;
            text-align: center;
            /* 텍스트도 가운데 */
        }

        /* 1줄차: 문의 · 제작 · 버전 */
        .site-footer .row {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            /* 가로 가운데 */
            align-items: center;
            gap: 8px;
        }

        .site-footer .sep {
            opacity: .6;
            margin: 0 6px;
        }

        .site-footer a {
            color: #9bb3cf;
            text-decoration: none;
        }

        .site-footer a:hover {
            text-decoration: underline;
        }

        /* 2줄차: 토글(요약) */
        .site-footer details {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            /* 요약 가운데 */
        }

        .site-footer summary {
            list-style: none;
            cursor: pointer;
            color: #9db7d9;
            font-weight: 700;
            outline: none;
            display: inline-block;
        }

        .site-footer summary::-webkit-details-marker {
            display: none;
        }

        /* 3줄차: 열렸을 때 닉네임 칩이 중앙 한 줄(여러 줄로 감싸짐) */
        .site-footer .chip-wrap {
            display: none;
            /* 기본 숨김(닫힘) */
            justify-content: center;
            /* 가운데 정렬 */
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 6px;
        }

        .site-footer details[open] .chip-wrap {
            display: flex;
        }

        .site-footer .chip {
            padding: 4px 8px;
            border-radius: 999px;
            border: 1px solid #20304a;
            background: #0b1220;
            color: #cfe0fb;
            white-space: nowrap;
            font-size: 11px;
            letter-spacing: .1px;
            user-select: text;
        }

        .rbody tbody tr.in-team1 {
            background: #0b1422;
            /* 단색 */
            box-shadow: inset 0 0 0 2px rgba(77, 163, 255, .35);
            border-color: #234a78;
        }

        .rbody tbody tr.in-team2 {
            background: #0b1422;
            /* 단색 */
            box-shadow: inset 0 0 0 2px rgba(239, 68, 68, .35);
            border-color: #5a2330;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/exceljs/dist/exceljs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

</head>

<body>
    <div class="wrap">
        <h1>팀 매칭 & 점수 관리</h1>
        <div class="grid">
            <!-- Left: Teams -->
            <div class="panel">
                <div class="hd">
                    <div class="title">Teams</div>
                </div>
                <div class="bd">
                    <div class="teamControls">
                        <label class="muted">팀 섞기 기준
                            <select id="balanceMode">
                                <!-- <option value="ignore_line">라인무시</option> -->
                                <option value="prefer_line" selected>라인우선</option>
                                <option value="prefer_mmr">MMR우선</option>
                            </select>
                            <label class="muted">균형 허용치
                                <input id="mmrTolerance" type="number" value="120" style="width:90px" />
                            </label>
                            <label class="muted" style="display: none;">섞기 강도
                                <select id="mixStrength">
                                    <option value="normal" selected>보통</option>
                                    <option value="strong">강함</option>
                                </select>
                            </label>
                        </label>
                        <label class="muted">팀 정렬
                            <select id="teamSort">
                                <option value="name" selected>이름 ▲</option>
                                <option value="line">주/부라인</option>
                                <option value="wr">승률 ▲</option>
                                <option value="score">점수 ▲</option>
                            </select>
                        </label>
                    </div>

                    <div class="teams">
                        <div class="team" id="team1Box">
                            <h3>1팀 <span class="avg" id="avg1">평균 0</span></h3>
                            <ul id="team1"></ul>
                        </div>
                        <div class="team" id="team2Box" style="margin-top:15px;">
                            <h3>2팀 <span class="avg" id="avg2">평균 0</span></h3>
                            <ul id="team2"></ul>
                        </div>
                    </div>

                    <div class="winbar" style="margin-top:10px">
                        <div class="winbar-left">
                            <label class="muted">점수 방식
                                <select id="scoringMode">
                                    <option value="elo">Elo 레이팅</option>
                                    <option value="fixed">고정 가산/감산</option>
                                </select>
                            </label>

                            <label class="muted" id="eloKWrap">Elo K
                                <input id="eloK" type="number" value="60" />
                            </label>

                            <label class="muted" id="winBonusWrap">승리 보상
                                <input id="winBonusInput" type="number" value="30" />
                            </label>

                            <div class="wins">
                                <button class="btn success" id="btnWin1" title="1팀 승">1팀 승리</button>
                                <button class="btn success" id="btnWin2" title="2팀 승">2팀 승리</button>
                                <button class="btn ghost" id="btnUndo" title="마지막 결과 되돌리기" disabled>되돌리기</button>
                            </div>
                        </div>

                        <div class="winbar-right">
                            <button class="btn ghost" id="btnCopyTeamsText" title="팀 구성 텍스트 복사">팀 구성 복사</button>
                            <button class="btn primary" id="btnRemakeTeams">현재 멤버로 팀 다시 짜기</button>
                            <button class="btn ghost" id="btnClearTeams">팀 비우기</button>
                        </div>
                    </div>

                    <div class="muted" style="padding-top:15px;">배치: 각 플레이어의 <b>현재 판수가 ≤ 10</b>이면 점수 변화가 <b>2배</b>로
                        적용됩니다.</div>
                    <div class="muted" style="padding-top:15px;">고정감산을 선택할 경우 승리 보상만큼의 점수가 가산/감산 됩니다.</div>
                    <div class="muted" style="padding-top:15px;">멤버를 인원관리에 드래그 드롭하여 제외할 수 있습니다.</div>
                </div>
            </div>

            <!-- Right: Roster + IO -->
            <div class="panel">
                <div class="hd">
                    <div class="title">인원 관리</div>
                </div>
                <div class="bd">
                    <div class="listbar manage" style="gap:10px;align-items:center;flex-wrap:wrap;padding-bottom:12px;">
                        <input class="grow" id="nameInput" type="text" placeholder="이름 (최대 16자)" />
                        <input style="width:120px" id="scoreInput" type="number" placeholder="초기 점수" value="1000" />
                        <label class="muted">주라인
                            <select id="linePrimaryInput" class="line-select">
                                <option value="A" selected>All</option>
                                <option value="T">Top</option>
                                <option value="J">Jungle</option>
                                <option value="M">Mid</option>
                                <option value="B">Bottom</option>
                                <option value="S">Supporter</option>
                            </select>
                        </label>
                        <label class="muted">부라인
                            <select id="lineSecondaryInput" class="line-select">
                                <option value="A" selected>All</option>
                                <option value="T">Top</option>
                                <option value="J">Jungle</option>
                                <option value="M">Mid</option>
                                <option value="B">Bottom</option>
                                <option value="S">Supporter</option>
                            </select>
                        </label>
                        <button class="btn" id="btnAdd">인원추가</button>

                    </div>

                    <!-- ▼ 이름 검색 바 추가 -->
                    <div class="listbar" style="gap:10px;align-items:center;padding-bottom:10px;">
                        <input id="rosterSearch" type="text" placeholder="이름 검색 (최소 1자)" style="width:220px" />
                        <button class="btn small ghost" id="rosterSearchClear" title="검색 지우기">지우기</button>
                        <span class="muted" id="rosterSearchCount">전체 0명</span>
                        <span class="muted" id="selectedNames" style="white-space:nowrap;"></span>
                    </div>
                    <!-- ▲ 이름 검색 바 -->

                    <div class="rosterTable" id="managePanel">
                        <table class="rhead" style="padding-left : 10px; padding-right:15px;">
                            <colgroup>
                                <col style="width:44px" />
                                <col style="width:180px" />
                                <col style="width:110px" />
                                <col style="width:60px" />
                                <col style="width:60px" />
                                <col style="width:90px" />
                                <col style="width:50px" />
                            </colgroup>
                            <thead>
                                <tr>
                                    <th><input type="checkbox" id="checkAll"></th>
                                    <th class="sortable" data-sort="name">이름 <span class="sort-ind"></span></th>
                                    <th class="sortable" data-sort="line">라인<br><span class="muted"
                                            style="font-weight:400;">주/부</span> <span class="sort-ind"></span></th>
                                    <th class="sortable" data-sort="score">점수 <span class="sort-ind"></span></th>
                                    <th class="sortable" data-sort="games">판수 <span class="sort-ind"></span></th>
                                    <th class="sortable" data-sort="wl">승/패 <span class="sort-ind"></span></th>
                                    <th class="sortable" data-sort="wr">승률 <span class="sort-ind"></span></th>
                                </tr>
                            </thead>
                        </table>
                        <div class="rscroll">
                            <table class="rbody">
                                <colgroup>
                                    <col style="width:44px" />
                                    <col style="width:180px" />
                                    <col style="width:110px" />
                                    <col style="width:60px" />
                                    <col style="width:60px" />
                                    <col style="width:90px" />
                                    <col style="width:50px" />
                                </colgroup>
                                <tbody id="rosterBody"></tbody>
                            </table>
                        </div>
                    </div>
                    <div class="bar">
                        <button class="btn primary" id="btnMakeTeams">선택한 인원으로 팀 짜기</button>
                        <button class="btn ghost" id="btnToTeam1">선택 → 1팀</button>
                        <button class="btn ghost" id="btnToTeam2">선택 → 2팀</button>
                        <button class="btn ghost" id="btnRemoveFromTeams">선택한 인원을 팀에서 제거</button>
                        <div class="muted">멤버를 팀에 드래그 드롭하여 추가할 수 있습니다.</div>
                    </div>
                    <div class="listbar" style="padding-bottom:12px">
                        <button class="btn warn" id="btnDelete">인원 삭제(선택)</button>
                        <button class="btn" id="btnSave">텍스트로 저장</button>
                        <button class="btn" id="btnExportXLSX">엑셀(XLSX)로 내보내기</button>
                        <span class="muted">현재 멤버 목록을 저장하여 불러올 수 있습니다.</span>
                    </div>
                    <div class="listbar" style="padding-bottom:12px">
                        <input id="fileInput" type="file" accept=".txt,.json,.xlsx" />
                        <button class="btn" id="btnLoad">불러오기</button>
                        <span class="muted">파일을 인원관리 리스트에 드래그하여 불러올 수 있습니다.</span>
                        <div class="muted" style="padding-top:15px;">
                            티어 예시 (400점 단위):<br>
                            Iron: 0–399<br>
                            Bronze: 400–799<br>
                            Silver: 800–1199<br>
                            Gold: 1200–1599<br>
                            Platinum: 1600–1999<br>
                            Emerald: 2000–2399<br>
                            Diamond: 2400–2799<br>
                            Master: 2800–3199<br>
                            Grandmaster: 3200–3599<br>
                            Challenger: 3600+
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <footer class="site-footer">
            <div class="inner">
                <!-- 1줄: 가운데 정렬 -->
                <div class="row">
                    <span><strong>문의</strong> : dosirak2332@daum.net</span>
                    <span class="sep">|</span>
                    <span><strong>제작</strong> : 도시락</span>
                </div>

                <!-- 2줄: “테스트 & 도움 주신 분들” 버튼(요약) -->
                <details>
                    <summary>테스트 & 도움 주신 분들</summary>

                    <!-- 3줄: 열렸을 때 닉네임 칩 표시 -->
                    <div class="chip-wrap">
                        <span class="chip">겨울</span>
                        <span class="chip">월레스와그로밋</span>
                        <span class="chip">구름전자</span>
                        <span class="chip">피스들틱</span>
                        <span class="chip">DECOx27</span>
                        <span class="chip">말구섭이</span>
                        <span class="chip">Poroo</span>
                        <span class="chip">럭스지키기</span>
                        <span class="chip">원딜아나대신살아</span>
                        <span class="chip">13131331</span>
                        <span class="chip">잠실고졸장재혁</span>
                        <span class="chip">Manza</span>
                        <span class="chip">진규호</span>
                        <span class="chip">KKiinKKiin</span>
                        <span class="chip">금성</span>
                        <span class="chip">김밥</span>
                        <span class="chip">나루</span>
                        <span class="chip">낸낫노이</span>
                        <span class="chip">무뇽</span>
                        <span class="chip">소프트</span>
                        <span class="chip">유씨</span>
                        <span class="chip">지망</span>
                        <span class="chip">지호</span>
                    </div>
                </details>
            </div>
        </footer>

    </div>

    <script>
        /* =========================
            상태/상수/유틸 (필요한 것만)
        ========================= */
        const STORAGE_KEY = 'team_roster_v1', WIN_BONUS_KEY = 'win_bonus_v1', MODE_KEY = 'scoring_mode_v1', ELO_K_KEY = 'elo_k_v1';
        let roster = [];
        let currentTeams = { team1: [], team2: [] };
        let teamHistory = []; const HISTORY_LIMIT = 5;
        let lastTeams = { team1: [], team2: [] };
        let lastResultUndo = null; // 승리 반영 전 스냅샷

        const uid = () => Math.random().toString(36).slice(2, 10);
        const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
        const avg = a => a.length ? (a.reduce((s, x) => s + x, 0) / a.length) : 0;
        const isPlacement = g => (Number(g) || 0) <= 10;
        const winRate = p => { const w = +p.wins || 0, l = +p.losses || 0, t = w + l; return t ? Math.round((w / t) * 100) : 0 };
        const wrClass = r => r >= 53 ? 'wr-good' : (r <= 47 ? 'wr-bad' : '');
        const LINES = ['T', 'J', 'M', 'B', 'S', 'A'];
        const LINE_TITLE = { T: 'Top', J: 'Jungle', M: 'Mid', B: 'Bottom', S: 'Supporter', A: 'All' };
        const normLine = v => { v = String(v || 'A').toUpperCase(); return LINES.includes(v) ? v : 'A'; };
        const linePair = p => `${normLine(p.mainLine)}/${normLine(p.subLine)}`;
        const escapeHtml = s => String(s || '').replace(/[&<>"']/g, ch => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "'": "&#039;" }[ch]));

        function pushHistory(split) {
            teamHistory.unshift({ team1: (split.team1 || []).slice(), team2: (split.team2 || []).slice() });
            if (teamHistory.length > HISTORY_LIMIT) teamHistory.pop();
        }

        /* ============ 다양성(스왑 고려) ============ */
        function countSameSideEither(t1Ids, t2Ids, base = lastTeams) {
            const last1 = new Set(base.team1 || []), last2 = new Set(base.team2 || []);
            let c1 = 0; for (const id of t1Ids) if (last1.has(id)) c1++; for (const id of t2Ids) if (last2.has(id)) c1++;
            let c2 = 0; for (const id of t1Ids) if (last2.has(id)) c2++; for (const id of t2Ids) if (last1.has(id)) c2++;
            return Math.max(c1, c2);
        }
        function countSameSideMultiEither(t1Ids, t2Ids, histories = teamHistory.length ? teamHistory : [lastTeams]) {
            let m = 0; for (const h of histories) { const c = countSameSideEither(t1Ids, t2Ids, h); if (c > m) m = c; } return m;
        }

        /* ============ 저장/로드 ============ */
        function saveLocal() { localStorage.setItem(STORAGE_KEY, JSON.stringify(roster)); }
        function loadLocal() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if (raw) {
                    const data = JSON.parse(raw);
                    if (Array.isArray(data)) {
                        roster = data.filter(x => x && x.name).map(x => ({
                            id: x.id || uid(),
                            name: String(x.name || '').trim(),
                            score: +x.score || 0,
                            games: Math.max(0, Math.floor(+x.games || 0)),
                            wins: Math.max(0, Math.floor(+x.wins || 0)),
                            losses: Math.max(0, Math.floor(+x.losses || 0)),
                            mainLine: normLine(x.mainLine),
                            subLine: normLine(x.subLine),
                        }));
                    }
                }
            } catch (e) { console.warn(e); }
        }

        /* ============ DOM ============ */
        const rosterBody = document.getElementById('rosterBody');
        const checkAll = document.getElementById('checkAll');
        const nameInput = document.getElementById('nameInput');
        const scoreInput = document.getElementById('scoreInput');
        const winBonusInput = document.getElementById('winBonusInput');
        const scoringModeSel = document.getElementById('scoringMode');
        const eloKInput = document.getElementById('eloK');
        const fileInput = document.getElementById('fileInput');
        const team1UL = document.getElementById('team1');
        const team2UL = document.getElementById('team2');
        const team1Box = document.getElementById('team1Box');
        const team2Box = document.getElementById('team2Box');
        const linePrimaryInput = document.getElementById('linePrimaryInput');
        const lineSecondaryInput = document.getElementById('lineSecondaryInput');
        const balanceModeSel = document.getElementById('balanceMode');
        const teamSortSel = document.getElementById('teamSort');
        const mmrToleranceInput = document.getElementById('mmrTolerance');
        const mixStrengthSel = document.getElementById('mixStrength');
        const rosterSearchInput = document.getElementById('rosterSearch');
        const rosterSearchClear = document.getElementById('rosterSearchClear');
        const rosterSearchCount = document.getElementById('rosterSearchCount');
        const selectedNamesEl = document.getElementById('selectedNames');
        const eloKWrap = document.getElementById('eloKWrap');
        const winBonusWrap = document.getElementById('winBonusWrap');
        const managePanel = document.getElementById('managePanel');
        const btnUndo = document.getElementById('btnUndo');
        function setUndoEnabled(on) {
            if (!btnUndo) return;
            btnUndo.disabled = !on;
            btnUndo.title = on ? '마지막 결과 되돌리기' : '되돌릴 결과가 없습니다';
        }
        // 초기 비활성화
        setUndoEnabled(false);

        const BALANCE_MODE_KEY = 'balance_mode_v1';
        const MMR_TOLERANCE_KEY = 'mmr_tolerance_v1';

        let rosterSortKey = 'name';   // name | line | score | wl | wr
        let rosterSortAsc = true;     // true: 오름차순, false: 내림차순

        let rosterSearchTerm = '';

        const lineOptionsHTML = (sel) => ['T', 'J', 'M', 'B', 'S', 'A'].map(k => `<option value="${k}" ${sel === k ? 'selected' : ''} title="${LINE_TITLE[k]}">${k}</option>`).join('');

        /* ============ 라인 배정 ============ */
        function assignRoles(team) {
            const roles = ['T', 'J', 'M', 'B', 'S'], used = new Set(), assignment = {}; let primaryAssigned = 0;
            for (const r of roles) { const i = team.findIndex(p => !used.has(p.id) && normLine(p.mainLine) === r); if (i >= 0) { used.add(team[i].id); assignment[r] = team[i].id; primaryAssigned++; } }
            for (const r of roles) { if (assignment[r]) continue; const i = team.findIndex(p => !used.has(p.id) && normLine(p.subLine) === r); if (i >= 0) { used.add(team[i].id); assignment[r] = team[i].id; } }
            for (const r of roles) { if (assignment[r]) continue; const i = team.findIndex(p => !used.has(p.id) && (normLine(p.mainLine) === 'A' || normLine(p.subLine) === 'A')); if (i >= 0) { used.add(team[i].id); assignment[r] = team[i].id; } }
            return { coveredRoles: Object.keys(assignment).length, primaryAssigned };
        }

        /* ============ 평가 함수(핵심) ============ */
        function scoreSplit(t1, t2, mode, allowDiff) {
            const m1 = avg(t1.map(p => p.score)), m2 = avg(t2.map(p => p.score)), diff = Math.abs(m1 - m2);
            const sdev = a => { const m = avg(a); return a.length ? Math.sqrt(a.reduce((s, x) => s + (x - m) * (x - m), 0) / a.length) : 0 };
            const s1 = sdev(t1.map(p => p.score)), s2 = sdev(t2.map(p => p.score));

            let a1 = { coveredRoles: 0, primaryAssigned: 0 }, a2 = { coveredRoles: 0, primaryAssigned: 0 };
            if (mode === 'prefer_line') { a1 = assignRoles(t1); a2 = assignRoles(t2); }

            // 파라미터
            let wCover = 0, wPrimary = 0, jitterAmp = 1.5, diversityW = 1.5, mmrDiv = 180;
            if (mode === 'prefer_line') { wCover = 12; wPrimary = 4; jitterAmp = 0.8; diversityW = 1.2; mmrDiv = 120; }
            else { jitterAmp = 4.0; diversityW = 4.0; mmrDiv = 200; }

            // ★ 라인 공정성 보너스: 주라인 더 많은 팀의 평균이 더 낮을수록 +
            let lineFairBonus = 0;
            if (mode === 'prefer_line') {
                const gap = (a1.primaryAssigned || 0) - (a2.primaryAssigned || 0); // +면 팀1이 주라인多
                if (gap !== 0) {
                    const favSign = Math.sign(gap);                  // +1: 팀1 유리
                    const fairRaw = favSign * (m2 - m1);            // 유리팀 평균이 낮을수록 +
                    const wFair = 0.25;                             // 튜닝
                    lineFairBonus = clamp(fairRaw * wFair * Math.abs(gap), -60, 60);
                }
            }

            // ★ 승률 보정 보너스: 평균 승률 낮은 팀의 평균 MMR이 더 높을수록 +
            let wrCompBonus = 0;
            {
                const wr1 = avg(t1.map(winRate)), wr2 = avg(t2.map(winRate));
                const wrGap = wr2 - wr1;                            // >0: 팀1 승률 낮음
                if (Math.abs(wrGap) > 0) {
                    const favSign = Math.sign(wrGap);               // +1: 팀1 낮은 승률
                    const compRaw = favSign * (m1 - m2);            // 낮은 승률 팀 평균이 높을수록 +
                    const wWR = 0.30;                               // 튜닝
                    const wrScale = clamp(Math.abs(wrGap) / 20, 0, 1); // 0~20% 구간 가중
                    wrCompBonus = clamp(compRaw * wWR * (1 + wrScale * 0.5), -80, 80);
                }
            }

            // 페널티들
            const over = Math.max(0, diff - allowDiff);
            const mmrPenalty = (over * over) / mmrDiv;
            const spreadPenalty = Math.abs(s1 - s2) * 0.18;

            const ids1 = t1.map(p => p.id), ids2 = t2.map(p => p.id);
            const sameSideMax = countSameSideMultiEither(ids1, ids2);
            const total = (ids1.length + ids2.length) || 1;
            const identicalPenalty = (sameSideMax === total) ? 1e6 : 0;
            const diversityPenalty = sameSideMax * diversityW;

            // 하드 가드: 허용치 초과 강제 제재
            const hardPenalty = over > 0 ? over * over * 250 : 0;

            const jitter = (Math.random() - 0.5) * jitterAmp;

            return ((a1.coveredRoles + a2.coveredRoles) * wCover + (a1.primaryAssigned + a2.primaryAssigned) * wPrimary
                + lineFairBonus + wrCompBonus)
                - mmrPenalty - spreadPenalty - diversityPenalty - identicalPenalty - hardPenalty
                + jitter;
        }

        /* ============ 탐색/보정 ============ */
        function improveBySwaps(pick, map, mode, allowDiff, rounds = 260, temp = 1.4, minChange = 2) {
            let best = JSON.parse(JSON.stringify(pick));
            let bestScore = scoreSplit(best.team1.map(id => map.get(id)), best.team2.map(id => map.get(id)), mode, allowDiff);
            let ids1 = best.team1.slice(), ids2 = best.team2.slice();

            for (let r = 0; r < rounds; r++) {
                const i = (Math.random() * ids1.length) | 0, j = (Math.random() * ids2.length) | 0;
                [ids1[i], ids2[j]] = [ids2[j], ids1[i]];
                const t1 = ids1.map(id => map.get(id)), t2 = ids2.map(id => map.get(id));
                let sc = scoreSplit(t1, t2, mode, allowDiff);

                const d1 = Math.abs(avg(t1.map(p => p.score)) - avg(t2.map(p => p.score)));
                if (d1 > allowDiff) sc -= (d1 - allowDiff) * 1e6;

                const changed = (ids1.length + ids2.length) - countSameSideEither(ids1, ids2, lastTeams);
                if (changed < minChange) sc -= (minChange - changed) * 15;

                const delta = sc - bestScore;
                if (delta >= 0 || Math.exp(delta / Math.max(0.001, temp)) > Math.random()) {
                    bestScore = sc; best.team1 = ids1.slice(); best.team2 = ids2.slice();
                } else {
                    [ids1[i], ids2[j]] = [ids2[j], ids1[i]];
                }
                temp *= 0.996;
            }
            return best;
        }
        function teamMeanByIds(ids, map) { if (!ids.length) return 0; let s = 0; for (const id of ids) s += map.get(id).score; return s / ids.length; }
        function mmrDiffOfPick(pick, map) { return Math.abs(teamMeanByIds(pick.team1, map) - teamMeanByIds(pick.team2, map)); }
        function reduceMMRGap(pick, map, targetDiff, maxIters = 120) {
            let iter = 0;
            while (iter++ < maxIters) {
                const before = mmrDiffOfPick(pick, map); if (before <= targetDiff) break;
                let bestGain = 0, bi = -1, bj = -1;
                for (let i = 0; i < pick.team1.length; i++) {
                    for (let j = 0; j < pick.team2.length; j++) {
                        const a = pick.team1[i], b = pick.team2[j];
                        [pick.team1[i], pick.team2[j]] = [b, a];
                        const after = mmrDiffOfPick(pick, map);
                        [pick.team1[i], pick.team2[j]] = [a, b];
                        const gain = before - after;
                        if (gain > bestGain) { bestGain = gain; bi = i; bj = j; }
                    }
                }
                if (bestGain > 0) { const a = pick.team1[bi], b = pick.team2[bj];[pick.team1[bi], pick.team2[bj]] = [b, a]; } else break;
            }
            return pick;
        }

        /* ============ 팀 빌드 ============ */
        function shuffle(a) { for (let i = a.length - 1; i > 0; i--) { const j = (Math.random() * (i + 1)) | 0;[a[i], a[j]] = [a[j], a[i]] } }
        function buildBalancedTeams(players, mode = 'prefer_line') {
            const n = players.length, half = n / 2, idx = [...Array(n).keys()];
            const allowDiff = Math.max(0, Math.round(Number(mmrToleranceInput?.value || 120)));
            const strength = (mixStrengthSel?.value || 'normal');

            let attemptsBase, swapBase, tempBase, minChangeDiv;
            if (mode === 'prefer_line') { attemptsBase = 900; swapBase = 320; tempBase = 1.5; minChangeDiv = 4; }
            else { attemptsBase = 2000; swapBase = 800; tempBase = 3.0; minChangeDiv = 2; }

            const attempts = Math.min((strength === 'strong' ? attemptsBase * 2 : attemptsBase) * n, 30000);
            const swapRounds = (strength === 'strong' ? Math.round(swapBase * 1.4) : swapBase);
            const initTemp = (strength === 'strong' ? tempBase * 1.2 : tempBase);
            const minChange = Math.max(2, Math.floor(n / minChangeDiv));

            let evalPlayers = players;
            if (mode === 'prefer_mmr') evalPlayers = players.map(p => ({ ...p, score: p.score + (Math.random() - 0.5) * 20 }));
            const map = new Map(evalPlayers.map(p => [p.id, p]));

            let best = null, bestScore = -Infinity;
            for (let a = 0; a < attempts; a++) {
                shuffle(idx);
                const t1 = idx.slice(0, half).map(i => evalPlayers[i]);
                const t2 = idx.slice(half).map(i => evalPlayers[i]);
                let sc = scoreSplit(t1, t2, mode, allowDiff);

                const d0 = Math.abs(avg(t1.map(p => p.score)) - avg(t2.map(p => p.score)));
                if (d0 > allowDiff) sc -= (d0 - allowDiff) * 1e6;

                const same = countSameSideMultiEither(t1.map(p => p.id), t2.map(p => p.id));
                const changed = (t1.length + t2.length) - same;
                if (changed < minChange) sc -= (minChange - changed) * 20;

                if (sc > bestScore) { bestScore = sc; best = { team1: t1.map(p => p.id), team2: t2.map(p => p.id) }; }
            }
            if (!best) return { team1: evalPlayers.slice(0, half).map(p => p.id), team2: evalPlayers.slice(half).map(p => p.id) };

            best = improveBySwaps(best, map, mode, allowDiff, swapRounds, initTemp, minChange);

            // 다양성 최소 보장
            const total = best.team1.length + best.team2.length;
            let changed = total - countSameSideMultiEither(best.team1, best.team2);
            if (changed < minChange) {
                const need = minChange - changed;
                for (let k = 0; k < need; k++) {
                    const i = (Math.random() * best.team1.length) | 0, j = (Math.random() * best.team2.length) | 0;
                    [best.team1[i], best.team2[j]] = [best.team2[j], best.team1[i]];
                }
                if (mode === 'prefer_mmr') {
                    for (let k = 0; k < best.team1.length; k++) {
                        if (Math.random() < 0.3) {
                            const i = (Math.random() * best.team1.length) | 0, j = (Math.random() * best.team2.length) | 0;
                            [best.team1[i], best.team2[j]] = [best.team2[j], best.team1[i]];
                        }
                    }
                }
            }

            // 허용치 충족 보정
            best = reduceMMRGap(best, map, allowDiff);
            return best;
        }

        function updateRosterHeaderIndicators() {
            const ths = document.querySelectorAll('.rhead thead th.sortable');
            ths.forEach(th => {
                const key = th.getAttribute('data-sort');
                const ind = th.querySelector('.sort-ind');
                if (!ind) return;
                if (key === rosterSortKey) {
                    ind.textContent = rosterSortAsc ? '▲' : '▼';
                    ind.style.opacity = '1';
                } else {
                    ind.textContent = '';
                    ind.style.opacity = '.5';
                }
            });
        }

        /* ============ 렌더: 로스터/팀 ============ */
        function renderRoster() {
            const key = rosterSortKey;
            const asc = rosterSortAsc ? 1 : -1;
            const term = rosterSearchTerm.trim().toLowerCase();

            const t1Set = new Set(currentTeams.team1 || []);
            const t2Set = new Set(currentTeams.team2 || []);

            const sorted = roster.slice().sort((a, b) => {
                const byName = a.name.localeCompare(b.name, 'ko');
                if (key === 'name') return asc * byName;

                if (key === 'line') {
                    const la = (normLine(a.mainLine) + '/' + normLine(a.subLine));
                    const lb = (normLine(b.mainLine) + '/' + normLine(b.subLine));
                    const cmp = la.localeCompare(lb);
                    return asc * (cmp || byName);
                }

                if (key === 'score') {
                    const cmp = (a.score - b.score);
                    return asc * (cmp || byName);
                }

                if (key === 'wl') {
                    const wa = +a.wins || 0, wb = +b.wins || 0;
                    const la = +a.losses || 0, lb = +b.losses || 0;
                    const cmp = (wa - wb) || (lb - la); // 승 많을수록↑, 승 같으면 패 적을수록↑
                    return asc * (cmp || byName);
                }

                if (key === 'wr') {
                    const ra = winRate(a), rb = winRate(b);
                    const cmp = (ra - rb);
                    return asc * (cmp || byName);
                }

                if (key === 'games') {
                    const ga = +a.games || 0, gb = +b.games || 0;
                    const cmp = (ga - gb);
                    return asc * (cmp || byName);
                }

                return byName;
            });
            const list = term ? sorted.filter(p => p.name.toLowerCase().includes(term)) : sorted;

            if (rosterSearchCount) {
                rosterSearchCount.textContent = term ? `검색 결과 ${list.length}명 / 전체 ${roster.length}명` : `전체 ${roster.length}명`;
            }

            rosterBody.innerHTML = '';
            list.forEach(p => {
                const tr = document.createElement('tr'); tr.setAttribute('draggable', 'true'); tr.dataset.id = p.id;
                if (t1Set.has(p.id)) tr.classList.add('in-team1');
                else if (t2Set.has(p.id)) tr.classList.add('in-team2');
                const rate = winRate(p);
                const p1 = normLine(p.mainLine || 'A'), p2 = normLine(p.subLine || 'A');
                const safe = escapeHtml(p.name);
                const highlighted = term ? safe.replace(new RegExp(`(${term.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\$&')})`, 'gi'), '<mark>$1</mark>') : safe;
                tr.innerHTML = `
                    <td><input type="checkbox" data-id="${p.id}" class="rowcheck"></td>
                    <td class="cell-name" data-id="${p.id}" title="더블클릭으로 이름 수정">${highlighted}</td>
                    <td class="cell-line">
                        <select class="line-select cell-line1" data-id="${p.id}" title="주 라인">${lineOptionsHTML(p1)}</select>
                        <span class="line-slash">/</span>
                        <select class="line-select cell-line2" data-id="${p.id}" title="부 라인">${lineOptionsHTML(p2)}</select>
                    </td>
                    <td class="tabnum"><input data-id="${p.id}" class="cell-score" type="number" value="${p.score}" /></td>
                    <td class="tabnum"><input data-id="${p.id}" class="cell-games" type="number" min="0" value="${p.games || 0}" /></td>
                    <td class="tabnum"><span class="wl-badge" data-id="${p.id}">${p.wins || 0}/${p.losses || 0}</span></td>
                    <td class="tabnum"><span class="wr-badge ${wrClass(rate)}" data-id="${p.id}">${rate}%</span></td>
                `;
                rosterBody.appendChild(tr);
            });
            if (checkAll) checkAll.checked = false;
            updateSelectedUI();
            updateRosterHeaderIndicators();
        }


        function renderTeams() {
            const t1 = currentTeams.team1.map(id => roster.find(p => p.id === id)).filter(Boolean);
            const t2 = currentTeams.team2.map(id => roster.find(p => p.id === id)).filter(Boolean);
            const a1 = avg(t1.map(p => p.score)), a2 = avg(t2.map(p => p.score));
            document.getElementById('avg1').innerHTML = `평균 <span class="${a1 >= a2 ? 'good' : 'bad'}">${a1.toFixed(1)}</span>`;
            document.getElementById('avg2').innerHTML = `평균 <span class="${a2 >= a1 ? 'good' : 'bad'}">${a2.toFixed(1)}</span>`;

            const sortKey = (teamSortSel && teamSortSel.value) || 'name';
            const cmp = (a, b) => {
                if (sortKey === 'name') return a.name.localeCompare(b.name, 'ko');
                if (sortKey === 'line') return linePair(a).localeCompare(linePair(b));
                if (sortKey === 'wr') return (winRate(b) - winRate(a)) || a.name.localeCompare(b.name, 'ko');
                if (sortKey === 'score') return (b.score - a.score) || a.name.localeCompare(b.name, 'ko');
                return 0;
            };
            t1.sort(cmp); t2.sort(cmp);

            team1UL.innerHTML = ''; team2UL.innerHTML = '';
            const makeRow = p => {
                const wr = winRate(p);
                const li = document.createElement('li');
                li.className = 'teamRow';
                li.setAttribute('draggable', 'true');
                li.dataset.id = p.id;

                const deltaHTML = (typeof p.lastDelta === 'number' && p.lastDelta !== 0)
                    ? `<span class="delta" style="color:${p.lastDelta > 0 ? '#22c55e' : '#ef4444'};">
         ${p.lastDelta > 0 ? '+' : ''}${p.lastDelta}
       </span>`
                    : '';

                li.innerHTML = `
                    <span class="cell-name" title="${escapeHtml(p.name)}">${escapeHtml(p.name)}</span>
                    <span class="cell-line tabnum" title="${LINE_TITLE[normLine(p.mainLine)]}/${LINE_TITLE[normLine(p.subLine)]}">
                        ${linePair(p)}
                    </span>
                    <span class="cell-wr tabnum ${wrClass(wr)}">${wr}%</span>
                    <span class="cell-score tabnum">
    <span class="score-num">${p.score}</span>${deltaHTML}
  </span>
                `;

                li.addEventListener('dragstart', e => {
                    e.dataTransfer.setData('text/plain', p.id);
                    e.dataTransfer.effectAllowed = 'move';
                });
                return li;
            };

            t1.forEach(p => team1UL.appendChild(makeRow(p)));
            t2.forEach(p => team2UL.appendChild(makeRow(p)));
        }

        /* ============ 드래그/드롭 ============ */
        function bindDropTarget(ulEl, boxEl, teamNo) {
            const onDragOver = e => { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; };
            const onDragEnter = () => boxEl.classList.add('drop-target');
            const onDragLeave = e => { if (!boxEl.contains(e.relatedTarget)) boxEl.classList.remove('drop-target'); };
            const onDrop = e => { e.preventDefault(); boxEl.classList.remove('drop-target'); const id = e.dataTransfer.getData('text/plain'); if (!id) return; addIdToTeam(teamNo, id); };
            ulEl.addEventListener('dragover', onDragOver);
            ulEl.addEventListener('dragenter', onDragEnter);
            ulEl.addEventListener('dragleave', onDragLeave);
            ulEl.addEventListener('drop', onDrop);
            boxEl.addEventListener('dragover', onDragOver);
            boxEl.addEventListener('dragenter', onDragEnter);
            boxEl.addEventListener('dragleave', onDragLeave);
            boxEl.addEventListener('drop', onDrop);
        }
        bindDropTarget(team1UL, team1Box, 1);
        bindDropTarget(team2UL, team2Box, 2);

        rosterBody.addEventListener('dragover', e => { e.preventDefault(); rosterBody.classList.add('drop-target'); });
        rosterBody.addEventListener('dragleave', e => { if (!rosterBody.contains(e.relatedTarget)) rosterBody.classList.remove('drop-target'); });
        rosterBody.addEventListener('drop', e => {
            e.preventDefault(); rosterBody.classList.remove('drop-target');
            const id = e.dataTransfer.getData('text/plain'); if (!id) return;
            currentTeams.team1 = currentTeams.team1.filter(x => x !== id);
            currentTeams.team2 = currentTeams.team2.filter(x => x !== id);
            renderTeams();
            renderRoster();
        });
        rosterBody.addEventListener('dragstart', e => {
            // 입력 요소에서 시작하면 드래그 취소 (편집 방해 방지)
            const tag = e.target.tagName;
            if (tag === 'INPUT' || tag === 'SELECT' || tag === 'BUTTON' || tag === 'A') return;

            const tr = e.target.closest('tr[draggable="true"]');
            if (!tr) return;

            const id = tr.dataset.id;
            if (id && e.dataTransfer) {
                e.dataTransfer.setData('text/plain', id);
                e.dataTransfer.effectAllowed = 'move';
            }
        });

        function addIdToTeam(teamNo, id) {
            if (!id) return;
            const other = teamNo === 1 ? currentTeams.team2 : currentTeams.team1;
            const target = teamNo === 1 ? currentTeams.team1 : currentTeams.team2;
            const otherSet = new Set(other), targetSet = new Set(target);
            if (otherSet.has(id)) otherSet.delete(id);
            targetSet.add(id);
            if (teamNo === 1) { currentTeams.team2 = [...otherSet]; currentTeams.team1 = [...targetSet]; }
            else { currentTeams.team1 = [...otherSet]; currentTeams.team2 = [...targetSet]; }

            roster.forEach(p => p.lastDelta = 0);

            renderTeams();
            renderRoster();
        }

        /* ============ 이벤트/액션 ============ */
        // 로스터 셀 변경
        rosterBody.addEventListener('change', e => {
            const t = e.target, id = t.dataset.id, p = roster.find(x => x.id === id); if (!p) return;
            if (t.classList.contains('rowcheck')) { updateSelectedUI(); return; }
            if (t.classList.contains('cell-line1')) p.mainLine = normLine(t.value);
            else if (t.classList.contains('cell-line2')) p.subLine = normLine(t.value);
            else if (t.classList.contains('cell-score')) p.score = isFinite(+t.value) ? +t.value : p.score;
            else if (t.classList.contains('cell-games')) p.games = Math.max(0, Math.floor(+t.value || 0));
            saveLocal(); renderTeams();
        });

        // 로스터 승패 초기화
        rosterBody.addEventListener('dblclick', e => {
            const wl = e.target.closest('.wl-badge'); if (!wl) return;
            const p = roster.find(x => x.id === wl.dataset.id); if (!p) return;
            if (confirm(`"${p.name}"의 승패를 초기화하시겠습니까?`)) {
                p.wins = 0; p.losses = 0; saveLocal(); renderRoster(); renderTeams();
            }
        });

        // 전체선택
        checkAll.addEventListener('change', () => {
            document.querySelectorAll('.rowcheck').forEach(cb => cb.checked = checkAll.checked);
            updateSelectedUI(); // 추가
        });

        // 검색
        let _searchTimer = null;
        function setSearchTerm(v) { rosterSearchTerm = (v || '').slice(0, 50); renderRoster(); }
        if (rosterSearchInput) {
            rosterSearchInput.addEventListener('input', (e) => {
                const v = e.target.value;
                clearTimeout(_searchTimer);
                _searchTimer = setTimeout(() => { setSearchTerm(v); updateSelectedUI(); }, 120);
            });
        }
        if (rosterSearchClear) {
            rosterSearchClear.addEventListener('click', () => {
                rosterSearchInput.value = '';
                setSearchTerm('');
                rosterSearchInput.focus();
                updateSelectedUI();
            });
        }

        function getSelectedIds() {
            return [...document.querySelectorAll('.rowcheck:checked')].map(cb => cb.dataset.id);
        }

        function updateSelectedUI() {
            const ids = getSelectedIds();
            const names = ids
                .map(id => (roster.find(p => p.id === id) || {}).name)
                .filter(Boolean);

            // 기존 "전체/검색 결과" 문구는 그대로 유지
            const total = roster.length;
            if (rosterSearchCount) {
                // 현재 화면에 표시된 행 수(검색 적용 후) 반영
                const visibleCount = document.querySelectorAll('#rosterBody tr').length;
                const term = (rosterSearchTerm || '').trim();
                const base = term
                    ? `검색 결과 ${visibleCount}명 / 전체 ${total}명`
                    : `전체 ${total}명`;
                rosterSearchCount.textContent = base;
            }

            // 선택 요약 출력 (이름은 많으면 접기)
            if (selectedNamesEl) {
                if (ids.length) {
                    const MAX = 8;
                    const shown = names.slice(0, MAX);
                    const more = names.length - shown.length;
                    selectedNamesEl.textContent =
                        ` | 선택 ${ids.length}명`;
                } else {
                    selectedNamesEl.textContent = '';
                }
            }
        }

        function toggleScoringControls() {
            const mode = (scoringModeSel && scoringModeSel.value) || 'elo';
            if (mode === 'elo') {
                if (eloKWrap) eloKWrap.style.display = '';
                if (winBonusWrap) winBonusWrap.style.display = 'none';
            } else { // fixed
                if (eloKWrap) eloKWrap.style.display = 'none';
                if (winBonusWrap) winBonusWrap.style.display = '';
            }
        }

        // 인원 추가/삭제
        document.getElementById('btnAdd').addEventListener('click', () => {
            let name = (nameInput.value || '').trim(); const score = +scoreInput.value || 0;
            const pLine = normLine(linePrimaryInput.value || 'A'), sLine = normLine(lineSecondaryInput.value || 'A');
            if (!name) { alert('이름을 입력하세요.'); nameInput.focus(); return; }
            if (name.length > 16) { alert('이름은 최대 16자까지만 가능합니다.'); name = name.slice(0, 16); }
            roster.push({ id: uid(), name, score, games: 0, wins: 0, losses: 0, mainLine: pLine, subLine: sLine });
            saveLocal(); renderRoster(); renderTeams();
            nameInput.value = ''; scoreInput.value = '1000'; linePrimaryInput.value = 'A'; lineSecondaryInput.value = 'A'; nameInput.focus();
        });

        document.getElementById('btnDelete').addEventListener('click', () => {
            const ids = new Set([...document.querySelectorAll('.rowcheck:checked')].map(cb => cb.dataset.id));
            if (!ids.size) { alert('삭제할 인원을 선택하세요.'); return; }
            const names = roster.filter(p => ids.has(p.id)).map(p => p.name).join(', ');
            if (!confirm(`정말 삭제하시겠습니까?\n${names}`)) return;
            roster = roster.filter(p => !ids.has(p.id));
            currentTeams.team1 = currentTeams.team1.filter(id => !ids.has(id));
            currentTeams.team2 = currentTeams.team2.filter(id => !ids.has(id));
            saveLocal(); renderRoster(); renderTeams();
        });

        // 저장/불러오기
        document.getElementById('btnSave').addEventListener('click', () => {
            const blob = new Blob([JSON.stringify(roster, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');

            const now = new Date();
            const pad = n => String(n).padStart(2, '0');

            // YYMMDD_HHMM 구성
            const yy = String(now.getFullYear()).slice(-2);
            const mm = pad(now.getMonth() + 1);
            const dd = pad(now.getDate());
            const HH = pad(now.getHours());
            const MM = pad(now.getMinutes());

            a.href = url;
            a.download = `member_${yy}${mm}${dd}_${HH}${MM}.txt`; // 예: member_250926_1320.txt
            a.click();
            URL.revokeObjectURL(url);
        });

        // ===== XLSX 내보내기 (Excel) - 현재 정렬 상태 유지, 검색 필터 무시 =====

        // 현재 테이블 정렬 상태(헤더 클릭으로 정한 rosterSortKey/rosterSortAsc)를 그대로 사용
        function getSortedRosterForExport() {
            const key = rosterSortKey;
            const asc = rosterSortAsc ? 1 : -1;

            // 검색어 필터는 내보내지 않으므로 roster 전체를 정렬만 적용
            const sorted = roster.slice().sort((a, b) => {
                const byName = a.name.localeCompare(b.name, 'ko');

                if (key === 'name') return asc * byName;

                if (key === 'line') {
                    const la = (normLine(a.mainLine) + '/' + normLine(a.subLine));
                    const lb = (normLine(b.mainLine) + '/' + normLine(b.subLine));
                    const cmp = la.localeCompare(lb);
                    return asc * (cmp || byName);
                }

                if (key === 'score') {
                    const cmp = (a.score - b.score);
                    return asc * (cmp || byName);
                }

                if (key === 'wl') {
                    const wa = +a.wins || 0, wb = +b.wins || 0;
                    const la = +a.losses || 0, lb = +b.losses || 0;
                    const cmp = (wa - wb) || (lb - la); // 승 많을수록↑, 승 같으면 패 적을수록↑
                    return asc * (cmp || byName);
                }

                if (key === 'wr') {
                    const ra = winRate(a), rb = winRate(b);
                    const cmp = (ra - rb);
                    return asc * (cmp || byName);
                }

                if (key === 'games') {
                    const ga = +a.games || 0, gb = +b.games || 0;
                    const cmp = (ga - gb);
                    return asc * (cmp || byName);
                }

                return byName;
            });

            return sorted;
        }

        // ===== XLSX 내보내기 (ExcelJS) - 현재 정렬 상태 유지 + 스타일 =====
        async function exportRosterXLSX({ onlySelected = false } = {}) {
            if (typeof ExcelJS === 'undefined') {
                alert('ExcelJS 로더를 찾을 수 없습니다. 스크립트 태그를 확인하세요.');
                return;
            }

            let list = getSortedRosterForExport(); // 현재 정렬 상태 그대로 사용

            if (onlySelected) {
                const ids = new Set(getSelectedIds());
                list = list.filter(p => ids.has(p.id));
            }

            // 워크북/시트 생성
            const wb = new ExcelJS.Workbook();
            const ws = wb.addWorksheet('멤버목록', {
                properties: { defaultRowHeight: 18 }
            });

            // 컬럼 정의 (이름 / 점수 / 판수 / 승 / 패 / 승률% / 주라인 / 부라인)
            ws.columns = [
                { header: '이름', key: 'name', width: 45 },
                { header: '점수', key: 'score', width: 10 },
                { header: '판수', key: 'games', width: 13 },
                { header: '승', key: 'wins', width: 12 },
                { header: '패', key: 'losses', width: 12 },
                { header: '승률(%)', key: 'wr', width: 10 },
                { header: '주라인', key: 'main', width: 10 },
                { header: '부라인', key: 'sub', width: 10 },
            ];

            // 데이터 행 추가
            list.forEach(p => {
                ws.addRow({
                    name: p.name,
                    score: p.score,
                    games: p.games || 0,
                    wins: p.wins || 0,
                    losses: p.losses || 0,
                    wr: winRate(p),
                    main: normLine(p.mainLine),
                    sub: normLine(p.subLine),
                });
            });

            // 헤더 스타일 (다크 톤 + 볼드 + 가운데 정렬)
            const headerRow = ws.getRow(1);
            headerRow.eachCell((cell) => {
                cell.fill = {
                    type: 'pattern',
                    pattern: 'solid',
                    fgColor: { argb: 'FF20304A' } // #20304a
                };
                cell.font = { bold: true, color: { argb: 'FFE6EEF8' } }; // #e6eef8
                cell.alignment = { vertical: 'middle', horizontal: 'center' };
                cell.border = {
                    bottom: { style: 'thin', color: { argb: 'FF1C2B45' } }
                };
            });

            // 보기 옵션: 헤더 고정
            ws.views = [{ state: 'frozen', ySplit: 1 }];

            // 본문 스타일: 이름(A), 주라인(G), 부라인(H) 가운데 정렬
            // 숫자 컬럼은 오른쪽 정렬
            for (let r = 2; r <= ws.rowCount; r++) {
                const row = ws.getRow(r);

                // 가운데: A(1), G(7), H(8)
                [1, 7, 8].forEach(c => {
                    row.getCell(c).alignment = { vertical: 'middle', horizontal: 'center' };
                });

                // 오른쪽: 점수(B2), 판수(C3), 승(D4), 패(E5), 승률(F6)
                [2, 3, 4, 5, 6].forEach(c => {
                    row.getCell(c).alignment = { vertical: 'middle', horizontal: 'right' };
                });
            }

            // 파일명: member_YYMMDD_HHMM.xlsx
            const now = new Date();
            const pad = n => String(n).padStart(2, '0');
            const yy = String(now.getFullYear()).slice(-2);
            const mm = pad(now.getMonth() + 1);
            const dd = pad(now.getDate());
            const HH = pad(now.getHours());
            const MM = pad(now.getMinutes());
            const filename = `member_${yy}${mm}${dd}_${HH}${MM}.xlsx`;

            // 저장
            const buf = await wb.xlsx.writeBuffer();
            const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }


        // 버튼 클릭 → 선택된 인원만 내보낼지 확인
        document.getElementById('btnExportXLSX').addEventListener('click', () => {
            const ids = getSelectedIds();
            if (ids.length > 0) {
                const onlySelected = confirm('선택된 인원만 내보낼까요?\n(확인: 선택만, 취소: 전체)');
                exportRosterXLSX({ onlySelected });
            } else {
                exportRosterXLSX({ onlySelected: false });
            }
        });


        window.addEventListener('dragover', e => e.preventDefault());
        window.addEventListener('drop', e => {
            // managePanel 외부에 드롭하면 네비게이션 방지
            if (!(e.target && managePanel && managePanel.contains(e.target))) {
                e.preventDefault();
            }
        });

        // 패널 하이라이트 on/off
        ['dragenter', 'dragover'].forEach(ev => {
            managePanel.addEventListener(ev, e => {
                if (!e.dataTransfer || !Array.from(e.dataTransfer.types || []).includes('Files')) return;
                e.preventDefault(); e.stopPropagation();
                managePanel.classList.add('dragover');
            });
        });
        ['dragleave', 'drop'].forEach(ev => {
            managePanel.addEventListener(ev, e => {
                e.preventDefault(); e.stopPropagation();
                managePanel.classList.remove('dragover');
            });
        });

        // 실제 드롭 처리
        managePanel.addEventListener('drop', e => {
            const files = e.dataTransfer?.files;
            if (!files || !files.length) return;
            const f = files[0];
            const name = (f.name || '').toLowerCase();

            if (name.endsWith('.xlsx')) {
                const reader = new FileReader();
                reader.onload = () => loadFromXLSX(reader.result);
                reader.readAsArrayBuffer(f);
                return;
            }

            if (name.endsWith('.txt') || name.endsWith('.json')) {
                const reader = new FileReader();
                reader.onload = () => loadFromText(String(reader.result || ''));
                reader.readAsText(f, 'utf-8');
                return;
            }

            alert('지원하지 않는 형식입니다. .txt, .json 또는 .xlsx 파일을 사용하세요.');
        });
        function loadFromText(text) {
            try {
                let data;
                const trimmed = String(text || '').trim();

                if (trimmed.startsWith('[') || trimmed.startsWith('{')) {
                    data = JSON.parse(trimmed);
                } else {
                    // 텍스트(CSV풍): 이름, 점수, 판수, 승, 패, 주라인, 부라인
                    data = trimmed.split(/\r?\n/).map(line => {
                        if (!line.trim()) return null;
                        const a = line.split(',').map(s => s.trim());
                        if (!a[0]) return null;
                        return {
                            name: a[0],
                            score: +a[1] || 0,
                            games: a[2] ? Math.floor(+a[2] || 0) : 0,
                            wins: a[3] ? Math.floor(+a[3] || 0) : 0,
                            losses: a[4] ? Math.floor(+a[4] || 0) : 0,
                            mainLine: a[5],
                            subLine: a[6]
                        };
                    }).filter(Boolean);
                }
                if (!Array.isArray(data)) data = [data];

                // 검증 + 보정
                const imported = [];
                const errs = [];

                data.forEach((it, i) => {
                    const rowNo = i + 1; // 텍스트는 대략 행 번호만
                    let name = String(it.name || '').slice(0, 16);
                    if (!name) return; // 빈 이름은 스킵
                    if (/^[=+\-@]/.test(name)) name = "'" + name;

                    const score = Number(it.score) || 0; // 점수는 음수 허용 요청 없음
                    const games = Math.floor(Number(it.games) || 0);
                    const wins = Math.floor(Number(it.wins) || 0);
                    const losses = Math.floor(Number(it.losses) || 0);

                    if (games < 0 || wins < 0 || losses < 0) {
                        errs.push(`행 ${rowNo}: 음수 값(games/wins/losses)`);
                    }

                    const toLetter = (v) => String(v || 'A').trim().toUpperCase().slice(0, 1);
                    const mainLine = normLine(toLetter(it.mainLine || 'A')); // 허용 외 → A
                    const subLine = normLine(toLetter(it.subLine || 'A'));

                    imported.push({
                        id: uid(),
                        name,
                        score,
                        games,
                        wins,
                        losses,
                        mainLine,
                        subLine
                    });
                });

                if (errs.length) {
                    const preview = errs.slice(0, 5).join('\n');
                    alert(`텍스트/JSON 불러오기 실패: 음수 값이 감지되었습니다.\n${preview}${errs.length > 5 ? `\n...외 ${errs.length - 5}건` : ''}`);
                    return;
                }

                if (!imported.length) {
                    alert('유효한 데이터 행을 찾지 못했습니다.');
                    return;
                }

                const prevCount = roster.length; // ★ 기존 인원 수 저장

                roster = imported;
                const valid = new Set(roster.map(p => p.id));
                currentTeams.team1 = currentTeams.team1.filter(id => valid.has(id));
                currentTeams.team2 = currentTeams.team2.filter(id => valid.has(id));

                saveLocal(); renderRoster(); renderTeams();

                alert(`${imported.length}명의 데이터를 불러와 인원 목록을 교체했습니다.`);
            } catch (e) {
                console.error(e);
                alert('불러오기 실패: 파일 형식을 확인하세요.');
            }
        }


        function loadFromXLSX(arrayBuffer) {
            try {
                const wb = XLSX.read(new Uint8Array(arrayBuffer), { type: 'array' });
                const first = wb.SheetNames && wb.SheetNames[0];
                if (!first) { alert('시트를 찾을 수 없습니다.'); return; }
                const ws = wb.Sheets[first];

                const rows = XLSX.utils.sheet_to_json(ws, { header: 1, blankrows: false });
                if (!rows.length) { alert('빈 시트입니다.'); return; }

                const header = rows[0].map(x => String(x || '').trim());
                const dataRows = rows.slice(1);

                const norm = s => String(s || '')
                    .replace(/\s+/g, '')
                    .replace(/[^가-힣a-zA-Z0-9]/g, '')
                    .toLowerCase();

                const headerIdx = {};
                header.forEach((h, i) => { headerIdx[norm(h)] = i; });

                const pick = (...alts) => {
                    for (const a of alts) {
                        const i = headerIdx[norm(a)];
                        if (i !== undefined) return i;
                    }
                    return null;
                };

                const idxName = pick('이름', 'name');
                const idxScore = pick('점수', 'score');
                const idxGames = pick('판수', 'games');
                const idxWins = pick('승', 'wins');
                const idxLosses = pick('패', 'losses');
                const idxMain = pick('주라인', '주 라인', 'mainline');
                const idxSub = pick('부라인', '부 라인', 'subline');

                if (idxName === null) {
                    alert('엑셀에 "이름" 열이 필요합니다. (내보낸 형식을 사용해주세요)');
                    return;
                }

                const get = (row, i, d = '') =>
                    (i === null || row[i] === undefined || row[i] === null) ? d : String(row[i]).trim();

                const toInt = (v, def = 0) => {
                    const n = Number(String(v).trim());
                    return Number.isFinite(n) ? Math.floor(n) : def;
                };

                const toLetter = (v) => String(v || 'A').trim().toUpperCase().slice(0, 1);

                const imported = [];
                const errs = [];

                dataRows.forEach((r, idx) => {
                    const rowNo = idx + 2; // 헤더 다음줄이 2행
                    let name = get(r, idxName, '');
                    if (!name) return; // 빈 이름은 스킵

                    // 이름 최대 16자 + 수식 주입 방지
                    name = name.slice(0, 16);
                    if (/^[=+\-@]/.test(name)) name = "'" + name;

                    const score = Number(get(r, idxScore, 0)) || 0; // 점수는 음수 허용 요청 없음
                    const games = toInt(get(r, idxGames, 0), 0);
                    const wins = toInt(get(r, idxWins, 0), 0);
                    const losses = toInt(get(r, idxLosses, 0), 0);

                    if (games < 0 || wins < 0 || losses < 0) {
                        errs.push(`행 ${rowNo}: 음수 값(games/wins/losses)`);
                    }

                    const mainLine = normLine(toLetter(get(r, idxMain, 'A'))); // 허용 외 → A
                    const subLine = normLine(toLetter(get(r, idxSub, 'A'))); // 허용 외 → A

                    imported.push({
                        id: uid(),
                        name,
                        score,
                        games,
                        wins,
                        losses,
                        mainLine,
                        subLine
                    });
                });

                if (errs.length) {
                    const preview = errs.slice(0, 5).join('\n');
                    alert(`엑셀 불러오기 실패: 음수 값이 감지되었습니다.\n${preview}${errs.length > 5 ? `\n...외 ${errs.length - 5}건` : ''}`);
                    return;
                }

                if (!imported.length) {
                    alert('유효한 데이터 행을 찾지 못했습니다.');
                    return;
                }

                roster = imported;
                const valid = new Set(roster.map(p => p.id));
                currentTeams.team1 = currentTeams.team1.filter(id => valid.has(id));
                currentTeams.team2 = currentTeams.team2.filter(id => valid.has(id));
                saveLocal(); renderRoster(); renderTeams();

                alert(`${imported.length}명의 데이터를 XLSX에서 불러와 인원 목록을 교체했습니다.`);
            } catch (e) {
                console.error(e);
                alert('XLSX 불러오기 중 오류가 발생했습니다.');
            }
        }




        document.getElementById('btnLoad').addEventListener('click', () => {
            const f = fileInput.files?.[0];
            if (!f) { alert('불러올 파일을 선택하세요.'); fileInput.click(); return; }

            const name = f.name.toLowerCase();

            // 확장자 분기
            if (name.endsWith('.xlsx')) {
                // XLSX는 이진이므로 ArrayBuffer로 읽기
                const reader = new FileReader();
                reader.onload = () => loadFromXLSX(reader.result);
                reader.readAsArrayBuffer(f);
            } else if (name.endsWith('.txt') || name.endsWith('.json')) {
                // 텍스트 계열은 문자열로 읽기
                const reader = new FileReader();
                reader.onload = () => loadFromText(String(reader.result || ''));
                reader.readAsText(f, 'utf-8');
            } else {
                alert('지원하지 않는 형식입니다. .txt, .json 또는 .xlsx 파일을 사용하세요.');
            }
        });

        // 팀 만들기/리메이크/정렬
        function teamsAlmostSame(a, b) {
            const A1 = new Set(a.team1), A2 = new Set(a.team2), tot = (a.team1.length + a.team2.length) || 1;
            let same = 0; for (const id of b.team1) if (A1.has(id)) same++; for (const id of b.team2) if (A2.has(id)) same++;
            let sameSwap = 0; for (const id of b.team1) if (A2.has(id)) sameSwap++; for (const id of b.team2) if (A1.has(id)) sameSwap++;
            return Math.max(same, sameSwap) / tot >= 0.85;
        }

        document.getElementById('btnMakeTeams').addEventListener('click', () => {
            const ids = [...document.querySelectorAll('.rowcheck:checked')].map(cb => cb.dataset.id);
            if (ids.length < 2 || ids.length % 2 !== 0) { alert('짝수 인원을 선택하세요. (현재 ' + ids.length + '명)'); return; }
            const players = ids.map(id => roster.find(p => p.id === id)).filter(Boolean);
            const mode = (balanceModeSel && balanceModeSel.value) || 'prefer_line';
            let pick = buildBalancedTeams(players, mode);
            if (teamsAlmostSame(pick, lastTeams) && mode !== 'prefer_line') {
                const bakT = mmrToleranceInput.value, bakS = mixStrengthSel.value;
                mmrToleranceInput.value = String(Math.floor(Number(bakT || 120) * 1.5)); mixStrengthSel.value = 'strong';
                pick = buildBalancedTeams(players, mode);
                mmrToleranceInput.value = bakT; mixStrengthSel.value = bakS;
            }
            currentTeams = pick;
            renderTeams();
            renderRoster();
            lastTeams = JSON.parse(JSON.stringify(currentTeams));
        });

        document.getElementById('btnRemakeTeams').addEventListener('click', () => {
            const all = [...currentTeams.team1, ...currentTeams.team2];
            if (all.length < 2 || all.length % 2 !== 0) {
                alert('먼저 짝수 인원으로 팀을 만들어주세요. (현재 ' + all.length + '명)');
                return;
            }
            const players = all.map(id => roster.find(p => p.id === id)).filter(Boolean);
            if (players.length !== all.length) {
                alert('일부 멤버가 목록에서 사라졌습니다. 다시 선택해서 팀을 만들어주세요.');
                return;
            }

            roster.forEach(p => p.lastDelta = 0);

            currentTeams = buildBalancedTeams(players, (balanceModeSel && balanceModeSel.value) || 'prefer_line');
            renderTeams();
            renderRoster();
            lastTeams = JSON.parse(JSON.stringify(currentTeams));
        });

        teamSortSel.addEventListener('change', renderTeams);

        document.getElementById('btnClearTeams').addEventListener('click', () => {

            roster.forEach(p => p.lastDelta = 0);

            currentTeams = { team1: [], team2: [] };
            lastTeams = { team1: [], team2: [] };
            renderTeams();
            document.getElementById('avg1').textContent = '평균 0';
            document.getElementById('avg2').textContent = '평균 0';
        });

        // 선택 이동/제거
        document.getElementById('btnToTeam1').addEventListener('click', () => {
            const ids = [...document.querySelectorAll('.rowcheck:checked')].map(cb => cb.dataset.id);
            if (!ids.length) { alert('팀에 넣을 인원을 체크하세요.'); return; }
            ids.forEach(id => addIdToTeam(1, id));
        });
        document.getElementById('btnToTeam2').addEventListener('click', () => {
            const ids = [...document.querySelectorAll('.rowcheck:checked')].map(cb => cb.dataset.id);
            if (!ids.length) { alert('팀에 넣을 인원을 체크하세요.'); return; }
            ids.forEach(id => addIdToTeam(2, id));
        });
        document.getElementById('btnRemoveFromTeams').addEventListener('click', () => {
            const ids = new Set([...document.querySelectorAll('.rowcheck:checked')].map(cb => cb.dataset.id));
            if (!ids.size) { alert('팀에서 제거할 인원을 체크하세요.'); return; }
            currentTeams.team1 = currentTeams.team1.filter(id => !ids.has(id));
            currentTeams.team2 = currentTeams.team2.filter(id => !ids.has(id));
            renderTeams();
            renderRoster();
        });

        // 승패 반영
        function confirmAndApply(winTeam) {
            const n1 = currentTeams.team1.length, n2 = currentTeams.team2.length;
            if (n1 === 0 || n2 === 0 || n1 !== n2) { alert('먼저 짝수 인원으로 팀을 만들어주세요.'); return; }
            const msg = `${winTeam === 1 ? '1팀 승리' : '2팀 승리'}로 점수를 반영할까요?`;
            if (confirm(msg)) applyResult(winTeam);
        }
        document.getElementById('btnWin1').addEventListener('click', () => confirmAndApply(1));
        document.getElementById('btnWin2').addEventListener('click', () => confirmAndApply(2));

        function applyResult(winTeam) {
            const ids1 = new Set(currentTeams.team1), ids2 = new Set(currentTeams.team2);
            if (ids1.size === 0 || ids2.size === 0 || ids1.size !== ids2.size) { alert('먼저 짝수 인원으로 팀을 만들어주세요.'); return; }
            // === 되돌리기 스냅샷(변경 전) 저장 ===
            const affectedIds = [...ids1, ...ids2];
            const undoSnapshot = affectedIds.map(id => {
                const p = roster.find(x => x.id === id);
                return p ? {
                    id: p.id,
                    score: p.score,
                    games: p.games || 0,
                    wins: p.wins || 0,
                    losses: p.losses || 0,
                    lastDelta: p.lastDelta || 0
                } : null;
            }).filter(Boolean);

            roster.forEach(p => p.lastDelta = 0);

            const targetBox = (winTeam === 1) ? team1Box : team2Box;
            launchConfetti(targetBox, { duration: 1800, count: 180 });

            const team1 = roster.filter(p => ids1.has(p.id)), team2 = roster.filter(p => ids2.has(p.id));
            const mode = (scoringModeSel && scoringModeSel.value) || 'fixed';

            if (mode === 'elo') {
                const R1 = avg(team1.map(p => p.score)), R2 = avg(team2.map(p => p.score));
                const E1 = 1 / (1 + Math.pow(10, (R2 - R1) / 400)), E2 = 1 - E1;
                const K = Math.round(Number(eloKInput && eloKInput.value ? eloKInput.value : 32)) || 32;
                const S1 = (winTeam === 1 ? 1 : 0), S2 = (winTeam === 2 ? 1 : 0);
                const d1 = K * (S1 - E1), d2 = K * (S2 - E2);

                team1.forEach(p => {
                    const mult = isPlacement(p.games) ? 2 : 1;
                    const change = Math.round(d1 * mult);
                    p.lastDelta = change;
                    p.score = Math.round(clamp(p.score + change, -9999, 9999));
                    p.games = (p.games || 0) + 1;
                    if (winTeam === 1) p.wins = (p.wins || 0) + 1; else p.losses = (p.losses || 0) + 1;
                });

                team2.forEach(p => {
                    const mult = isPlacement(p.games) ? 2 : 1;
                    const change = Math.round(d2 * mult);
                    p.lastDelta = change;
                    p.score = Math.round(clamp(p.score + change, -9999, 9999));
                    p.games = (p.games || 0) + 1;
                    if (winTeam === 2) p.wins = (p.wins || 0) + 1; else p.losses = (p.losses || 0) + 1;
                });
            } else {
                const delta = Math.round(Number(winBonusInput && winBonusInput.value ? winBonusInput.value : 10)) || 10;
                roster.forEach(p => {
                    const in1 = ids1.has(p.id), in2 = ids2.has(p.id);
                    if (!in1 && !in2) return;

                    const mult = isPlacement(p.games) ? 2 : 1;
                    let change = 0;
                    if (in1) change = (winTeam === 1 ? delta * mult : -delta * mult);
                    if (in2) change = (winTeam === 2 ? delta * mult : -delta * mult);

                    p.lastDelta = change; // ★ 기록
                    p.score = Math.round(clamp(p.score + change, -9999, 9999));
                    p.games = (p.games || 0) + 1;

                    if (in1) { if (winTeam === 1) p.wins = (p.wins || 0) + 1; else p.losses = (p.losses || 0) + 1; }
                    if (in2) { if (winTeam === 2) p.wins = (p.wins || 0) + 1; else p.losses = (p.losses || 0) + 1; }
                });
            }
            saveLocal(); renderRoster(); renderTeams();
            // === undo 가능 상태로 기록 ===
            lastResultUndo = { snapshot: undoSnapshot };
            setUndoEnabled(true);
        }

        function undoLastResult() {
            if (!lastResultUndo || !lastResultUndo.snapshot || !lastResultUndo.snapshot.length) {
                alert('되돌릴 결과가 없습니다.');
                return;
            }
            const map = new Map(lastResultUndo.snapshot.map(s => [s.id, s]));

            // 스냅샷으로 복구
            roster.forEach(p => {
                const s = map.get(p.id);
                if (s) {
                    p.score = s.score;
                    p.games = s.games;
                    p.wins = s.wins;
                    p.losses = s.losses;
                    p.lastDelta = 0; // 되돌린 상태 표시
                }
            });

            saveLocal();
            renderRoster();
            renderTeams();

            lastResultUndo = null;     // 단일 단계 되돌리기
            setUndoEnabled(false);
        }

        if (btnUndo) {
            btnUndo.addEventListener('click', undoLastResult);
        }


        /* ============ 환경설정 ============ */
        function initPrefs() {
            try {
                const v = localStorage.getItem(WIN_BONUS_KEY);
                if (v) winBonusInput.value = String(Math.round(+v || 10));
            } catch { }
            if (winBonusInput) winBonusInput.addEventListener('change', () => {
                const v = Math.round(+winBonusInput.value || 10);
                winBonusInput.value = String(v);
                try { localStorage.setItem(WIN_BONUS_KEY, String(v)); } catch { }
            });

            // 점수 방식
            try {
                const m = localStorage.getItem(MODE_KEY);
                if (m && scoringModeSel) scoringModeSel.value = m;
                const k = localStorage.getItem(ELO_K_KEY);
                if (k && eloKInput) eloKInput.value = String(Math.round(+k || 32));
            } catch { }
            toggleScoringControls();
            if (scoringModeSel) scoringModeSel.addEventListener('change', () => {
                try { localStorage.setItem(MODE_KEY, scoringModeSel.value); } catch { }
                toggleScoringControls();
            });
            if (eloKInput) eloKInput.addEventListener('change', () => {
                const v = Math.round(+eloKInput.value || 32);
                eloKInput.value = String(v);
                try { localStorage.setItem(ELO_K_KEY, String(v)); } catch { }
            });

            // ★ 팀 섞기 기준
            try {
                const bm = localStorage.getItem(BALANCE_MODE_KEY);
                if (bm && balanceModeSel) balanceModeSel.value = bm;
            } catch { }
            if (balanceModeSel) balanceModeSel.addEventListener('change', () => {
                try { localStorage.setItem(BALANCE_MODE_KEY, balanceModeSel.value); } catch { }
            });

            // ★ 균형 허용치
            try {
                const mt = localStorage.getItem(MMR_TOLERANCE_KEY);
                if (mt && mmrToleranceInput) mmrToleranceInput.value = mt;
            } catch { }
            if (mmrToleranceInput) mmrToleranceInput.addEventListener('change', () => {
                try { localStorage.setItem(MMR_TOLERANCE_KEY, mmrToleranceInput.value); } catch { }
            });
        }
        function buildTeamsText() {
            // id → 이름 매핑
            const nameById = new Map(roster.map(p => [p.id, p.name]));
            const n1 = currentTeams.team1.map(id => nameById.get(id)).filter(Boolean);
            const n2 = currentTeams.team2.map(id => nameById.get(id)).filter(Boolean);

            const s1 = n1.length ? n1.join(', ') : '(비어있음)';
            const s2 = n2.length ? n2.join(', ') : '(비어있음)';
            return `1팀 ${s1}\n2팀 ${s2}`;
        }

        async function copyToClipboard(text) {
            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(text);
                    return true;
                }
            } catch (e) { /* fallback으로 진행 */ }

            // Fallback (구형 브라우저)
            const ta = document.createElement('textarea');
            ta.value = text;
            ta.style.position = 'fixed';
            ta.style.left = '-9999px';
            document.body.appendChild(ta);
            ta.select();
            const ok = document.execCommand('copy');
            document.body.removeChild(ta);
            return ok;
        }

        const btnCopy = document.getElementById('btnCopyTeamsText');
        if (btnCopy) {
            btnCopy.addEventListener('click', async () => {
                const text = buildTeamsText();
                const ok = await copyToClipboard(text);
                const old = btnCopy.textContent;
                btnCopy.textContent = ok ? '복사 완료!' : '복사 실패';
                setTimeout(() => { btnCopy.textContent = old; }, 1200);
            });
        }

        // 헤더 클릭으로 정렬 토글
        document.querySelectorAll('.rhead thead th.sortable').forEach(th => {
            th.addEventListener('click', () => {
                const key = th.getAttribute('data-sort');
                if (!key) return;
                if (rosterSortKey === key) {
                    rosterSortAsc = !rosterSortAsc;      // 같은 키면 방향 토글
                } else {
                    rosterSortKey = key;                 // 다른 키면 키 변경 + 기본 오름차순
                    rosterSortAsc = true;
                }
                renderRoster(); // 목록 갱신 + 헤더 화살표 갱신
            });
        });

        // ====== 축하 폭죽 ======
        function launchConfetti(targetEl, opts = {}) {
            const duration = opts.duration ?? 1600; // ms
            const count = opts.count ?? 150;

            const BOUNCE = 0.45;        // 바닥/벽 반발계수 (0~1)
            const EDGE_FRICTION = 0.98; // 벽에 닿을 때 살짝 감속
            const GROUND_FRICTION = 0.90; // 바닥에서 미끄러질 때 감속

            // 캔버스 생성 및 타깃 위에 올리기
            const rect = targetEl.getBoundingClientRect();
            const canvas = document.createElement('canvas');
            canvas.style.position = 'absolute';
            canvas.style.left = '0';
            canvas.style.top = '0';
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.pointerEvents = 'none';
            targetEl.appendChild(canvas);

            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;

            function resize() {
                // 타깃 사이즈 기준으로 캔버스 픽셀 크기 설정
                const w = targetEl.clientWidth || rect.width;
                const h = targetEl.clientHeight || rect.height;
                canvas.width = Math.max(1, Math.floor(w * dpr));
                canvas.height = Math.max(1, Math.floor(h * dpr));
            }
            resize();

            // 중심에서 살짝 위쪽에서 터지면 보기 좋음
            const originX = canvas.width * 0.5;
            const originY = canvas.height * 1;

            // 확~ 퍼지게 하는 튜닝값
            const POWER = 1.5;         // 초기속도 배율
            const BASE_SPEED = 5;      // 기본 속도
            const SPEED_VAR = 8;       // 속도 가변폭
            const GRAVITY_MIN = 0.08;  // 중력 범위(낮출수록 더 오래/멀리)
            const GRAVITY_VAR = 0.08;
            const AIR_DRAG = 0.97;    // 공기저항(1에 가까우면 오래감)

            // 파티클 생성(360도 확산)
            const particles = Array.from({ length: count }, () => {
                const CENTER_DEG = -90;
                const SPREAD_DEG = 180;
                const theta = ((CENTER_DEG - SPREAD_DEG / 2) + Math.random() * SPREAD_DEG) * Math.PI / 180;
                const speed = (BASE_SPEED + Math.random() * SPEED_VAR) * POWER * dpr;
                return {
                    x: originX,
                    y: originY,
                    vx: Math.cos(theta) * speed,
                    vy: Math.sin(theta) * speed,
                    g: (GRAVITY_MIN + Math.random() * GRAVITY_VAR) * dpr,
                    w: (4 + Math.random() * 6) * dpr,
                    h: (6 + Math.random() * 10) * dpr,
                    rot: Math.random() * Math.PI,
                    vr: (Math.random() - 0.5) * 0.3,
                    color: ['#22c55e', '#4da3ff', '#f59e0b', '#ef4444', '#a78bfa', '#34d399'][(Math.random() * 6) | 0],
                    alpha: 1
                };
            });

            const start = performance.now();

            function step(t) {
                const elapsed = t - start;
                const progress = Math.min(1, elapsed / duration);

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                for (const p of particles) {
                    // 이동 + 감속 + 중력
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vx *= AIR_DRAG;
                    p.vy = p.vy * AIR_DRAG + p.g;
                    p.rot += p.vr;

                    // === 경계 충돌: 좌/우 벽 ===
                    if (p.x < 0) {
                        p.x = 0;
                        p.vx = -p.vx * BOUNCE;
                        p.vy *= EDGE_FRICTION;
                        p.vr *= EDGE_FRICTION;
                    } else if (p.x > canvas.width) {
                        p.x = canvas.width;
                        p.vx = -p.vx * BOUNCE;
                        p.vy *= EDGE_FRICTION;
                        p.vr *= EDGE_FRICTION;
                    }

                    // === 경계 충돌: 천장 ===
                    if (p.y < 0) {
                        p.y = 0;
                        p.vy = -p.vy * BOUNCE;
                        p.vx *= EDGE_FRICTION;
                        p.vr *= EDGE_FRICTION;
                    }

                    // === 경계 충돌: 바닥(중력 방향) ===
                    if (p.y > canvas.height) {
                        p.y = canvas.height;
                        // 아래로 내려오던 속도를 위로 튕기게
                        p.vy = -Math.abs(p.vy) * BOUNCE;

                        // 바닥에서 미끄러지며 감속
                        p.vx *= GROUND_FRICTION;
                        p.vr *= GROUND_FRICTION;

                        // 아주 느려지면 멈춘 느낌 주기
                        if (Math.abs(p.vy) < 0.25 * dpr) p.vy = 0;
                        if (Math.abs(p.vx) < 0.15 * dpr) p.vx = 0;
                    }

                    // 점점 사라지기
                    p.alpha = 1 - progress;

                    // 그리기
                    ctx.save();
                    ctx.globalAlpha = p.alpha;
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rot);
                    ctx.fillStyle = p.color;
                    ctx.fillRect(-p.w / 2, -p.h / 2, p.w, p.h);
                    ctx.restore();
                }


                if (progress < 1) {
                    requestAnimationFrame(step);
                } else {
                    // 마무리
                    targetEl.removeChild(canvas);
                }
            }

            requestAnimationFrame(step);
        }



        // ===== 초기화 =====
        loadLocal(); initPrefs();
        roster = roster.map(p => ({ ...p, mainLine: normLine(p.mainLine || 'A'), subLine: normLine(p.subLine || 'A') }));
        saveLocal();
        renderRoster(); renderTeams();
        toggleScoringControls();

    </script>
</body>

</html>
