<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>팀 매칭 & 점수 관리</title>
    <style>
        :root {
            --bg: #0b0f14;
            --panel: #111826;
            --muted: #8aa0b8;
            --text: #e6eef8;
            --acc: #4da3ff;
            --acc2: #22c55e;
            --warn: #ef4444;
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            font-family: Inter, Pretendard, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif;
            background: linear-gradient(180deg, #09111a, #0b0f14 30%, #0f172a);
            color: var(--text)
        }

        .wrap {
            margin: 28px auto;
            padding: 20px
        }

        h1 {
            font-size: 22px;
            margin: 0 0 14px;
            letter-spacing: .2px;
            display: flex;
            gap: 10px;
            align-items: center
        }

        .bar {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 14px;
            margin-bottom: 14px;
        }

        .btn {
            border: none;
            border-radius: 12px;
            padding: 10px 14px;
            font-weight: 600;
            background: #1e293b;
            color: #dbe7f8;
            cursor: pointer;
            transition: .15s
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(77, 163, 255, .15)
        }

        .btn.primary {
            background: var(--acc);
            color: #031427
        }

        .btn.success {
            background: var(--acc2);
            color: #06220f
        }

        .btn.warn {
            background: var(--warn)
        }

        .btn.ghost {
            background: #0b1220;
            color: #9db7d9;
            border: 1px solid #20304a
        }

        .btn.small {
            padding: 6px 10px;
            border-radius: 10px
        }

        /* ===== Layout ===== */
        .grid {
            display: grid;
            grid-template-columns: minmax(0, 0.7fr) minmax(500px, 1fr);
            gap: 14px;
            min-width: 0;
        }

        @media (max-width: 980px) {
            .grid {
                grid-template-columns: 1fr
            }
        }

        .panel {
            min-width: 0;
            overflow-x: hidden;
        }

        .panel .hd {
            padding: 12px 14px;
            border-bottom: 1px solid #1c2b45;
            display: flex;
            align-items: center;
            justify-content: space-between
        }

        .panel .hd .title {
            font-weight: 800;
            font-size: 14px;
            letter-spacing: .6px;
            text-transform: uppercase;
            color: #a9c3e6
        }

        .panel .bd {
            padding: 14px
        }

        .muted {
            color: var(--muted)
        }

        input[type="text"],
        input[type="number"] {
            background: #0a1220;
            border: 1px solid #233656;
            color: #e6eef8;
            border-radius: 10px;
            padding: 9px 11px
        }

        input[type="file"] {
            color: #9bb3cf
        }

        .team {
            border: 1px dashed #2a4168;
            border-radius: 14px;
            padding: 12px;
            background: linear-gradient(180deg, #0c1626, #0c1422);
            min-width: 0
        }

        .team h3 {
            margin: 0 0 8px;
            font-size: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center
        }

        .team ul {
            list-style: none;
            margin: 0;
            padding: 4px 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: 263px;
            overflow-y: auto;
            overflow-x: hidden;
            scrollbar-gutter: stable both-edges;
            padding-right: 6px;
        }

        /* 팀 행 */
        .teamRow {
            display: grid;
            grid-template-columns: minmax(12ch, 1fr) 80px 70px minmax(60px, max-content);
            gap: 8px;
            padding: 10px 14px;
            background: #0e1a2a;
            border: 1px solid #1f2e47;
            border-radius: 12px;
            align-items: center;
        }

        .teamRow:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 18px rgba(0, 0, 0, .25);
            transition: .15s;
        }

        .teamRow .cell-name {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            white-space: normal;
            text-overflow: unset;
            line-height: 1.3;
            text-align: center;
        }

        .teamRow .cell-line {
            text-align: center;
            opacity: .9
        }

        .teamRow .cell-wr {
            text-align: center
        }

        .teamRow .cell-score {
            text-align: right;
            justify-self: end;
            white-space: nowrap;
            min-width: 60px;
        }

        .tabnum {
            font-variant-numeric: tabular-nums;
            font-feature-settings: "tnum" 1
        }

        .avg {
            font-weight: 800
        }

        .avg .good {
            color: var(--acc2)
        }

        .avg .bad {
            color: #f59e0b
        }

        .winbar {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
            min-width: 0
        }

        .winbar label {
            align-items: center;
            gap: 6px;
        }

        .winbar label input {
            width: 80px;
            max-width: 80px
        }

        .winbar label select {
            max-width: 180px
        }

        .winbar .btn.success {
            min-width: 108px;
            white-space: nowrap;
            flex: 0 0 auto
        }

        .winbar .btn.ghost {
            white-space: nowrap
        }

        .teamControls {
            display: flex;
            gap: 8px;
            align-items: center;
            margin: 8px 0 12px
        }

        /* ===== Roster ===== */
        .rosterTable {
            border: 1px solid #1c2b45;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 10px
        }

        .rhead,
        .rbody {
            width: 100%;
            table-layout: fixed;
            border-collapse: separate;
            border-spacing: 0 8px
        }

        .rhead thead th {
            font-size: 12px;
            color: #8fb1d6;
            font-weight: 700;
            text-align: center;
            padding: 8px;
            background: #0c1422
        }

        .rscroll {
            max-height: 440px;
            overflow-y: auto;
            overflow-x: hidden;
            background: transparent;
            padding: 6px
        }

        .rbody tbody tr {
            background: linear-gradient(180deg, #0b1422, #0a111c);
            border: 1px solid #1c2b45
        }

        .rbody tbody tr td {
            padding: 10px 8px;
            text-align: center
        }

        .rbody tbody tr td:first-child {
            border-top-left-radius: 12px;
            border-bottom-left-radius: 12px
        }

        .rbody tbody tr td:last-child {
            border-top-right-radius: 12px;
            border-bottom-right-radius: 12px
        }

        .rbody .cell-name,
        .rhead th:nth-child(2) {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 12ch;
            text-align: center
        }

        .cell-line {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px
        }

        .line-select {
            width: 54px;
            height: 30px;
            background: #0a1220;
            border: 1px solid #233656;
            color: #e6eef8;
            border-radius: 8px;
            appearance: none;
            text-align: center
        }

        .rscroll input.cell-score,
        .rscroll input.cell-games {
            width: 100% !important;
            max-width: 100%;
            box-sizing: border-box
        }

        .wl-badge,
        .wr-badge {
            font-size: 11px;
            opacity: .85
        }

        .wr-good {
            color: var(--acc2)
        }

        .wr-bad {
            color: var(--warn)
        }

        select {
            max-width: 180px !important;
            background: #0a1220;
            border: 1px solid #233656;
            color: #e6eef8;
            border-radius: 10px;
            height: 34px;
            padding: 0 10px;
            appearance: none;
        }

        .listbar.manage {
            display: grid;
            grid-template-columns: minmax(180px, 1fr) 120px repeat(2, auto) auto auto;
            gap: 8px 12px;
            align-items: center;
        }

        @media (max-width: 1100px) {
            .listbar.manage {
                grid-template-columns: minmax(160px, 1fr) 110px auto auto;
            }
        }

        .listbar.manage #scoreInput {
            width: 110px !important;
        }

        #linePrimaryInput,
        #lineSecondaryInput {
            width: 80px;
            height: 28px;
            font-size: 12px;
        }

        .listbar.manage label[for="rosterSort"],
        .listbar.manage select#rosterSort {
            justify-self: end;
        }

        /* 검색어 하이라이트 */
        mark {
            background: rgba(77, 163, 255, .25);
            padding: 0 2px;
            border-radius: 3px;
        }

        .footer-note {
            text-align: center;
            margin-top: 18px;
            padding-top: 10px;
            border-top: 1px solid #1c2b45;
            color: var(--muted);
            font-size: 12px;
        }

        .footer-note a {
            color: #9db7d9;
            text-decoration: none;
        }

        .footer-note a:hover {
            text-decoration: underline;
        }

        #managePanel.dragover {
            outline: 2px dashed var(--acc);
            outline-offset: -6px;
            box-shadow: 0 0 0 3px rgba(77, 163, 255, .12) inset;
            background-image: linear-gradient(180deg, rgba(77, 163, 255, .06), transparent);
        }

        .rhead thead th.sortable {
            cursor: pointer;
            user-select: none;
            position: relative;
        }

        .sort-ind {
            font-weight: 800;
            margin-left: 4px;
            opacity: .9;
        }
    </style>
</head>

<body>
    <div class="wrap">
        <h1>팀 매칭 & 점수 관리</h1>
        <div class="grid">
            <!-- Left: Teams -->
            <div class="panel">
                <div class="hd">
                    <div class="title">Teams</div>
                </div>
                <div class="bd">
                    <div class="teamControls">
                        <label class="muted">팀 섞기 기준
                            <select id="balanceMode">
                                <!-- <option value="ignore_line">라인무시</option> -->
                                <option value="prefer_line" selected>라인우선</option>
                                <option value="prefer_mmr">MMR우선</option>
                            </select>
                            <label class="muted">균형 허용치
                                <input id="mmrTolerance" type="number" value="120" style="width:90px" />
                            </label>
                            <label class="muted">섞기 강도
                                <select id="mixStrength">
                                    <option value="normal" selected>보통</option>
                                    <option value="strong">강함</option>
                                </select>
                            </label>
                        </label>
                        <label class="muted">팀 정렬
                            <select id="teamSort">
                                <option value="name" selected>이름 ▲</option>
                                <option value="line">주/부라인</option>
                                <option value="wr">승률 ▲</option>
                                <option value="score">점수 ▲</option>
                            </select>
                        </label>
                    </div>

                    <div class="teams">
                        <div class="team" id="team1Box">
                            <h3>1팀 <span class="avg" id="avg1">평균 0</span></h3>
                            <ul id="team1"></ul>
                        </div>
                        <div class="team" id="team2Box" style="margin-top:15px;">
                            <h3>2팀 <span class="avg" id="avg2">평균 0</span></h3>
                            <ul id="team2"></ul>
                        </div>
                    </div>

                    <div class="winbar" style="margin-top:10px">
                        <div style="width: 100%;">
                            <label class="muted">점수 방식
                                <select id="scoringMode">
                                    <option value="elo">Elo 레이팅</option>
                                    <option value="fixed">고정 가산/감산</option>
                                </select>
                            </label>
                            <button class="btn success" id="btnWin1" title="1팀 승">1팀 승리</button>
                            <button class="btn success" id="btnWin2" title="2팀 승">2팀 승리</button>
                        </div>

                        <label class="muted" id="eloKWrap">Elo K <input id="eloK" type="number" value="60" /></label>
                        <label class="muted" id="winBonusWrap">승리 보상 <input id="winBonusInput" type="number"
                                value="30" /></label>
                        <div style="margin-left:auto;">
                            <button class="btn ghost" id="btnCopyTeamsText" title="팀 구성 텍스트 복사">팀 구성 복사</button>
                            <button class="btn primary" id="btnRemakeTeams">현재 멤버로 팀 다시 짜기</button>
                            <button class="btn ghost" id="btnClearTeams">팀 비우기</button>
                        </div>
                    </div>

                    <div class="muted" style="padding-top:15px;">배치: 각 플레이어의 <b>현재 판수가 ≤ 10</b>이면 점수 변화가 <b>2배</b>로
                        적용됩니다.</div>
                    <div class="muted" style="padding-top:15px;">고정감산을 선택할 경우 승리 보상만큼의 점수가 가산/감산 됩니다.</div>
                    <div class="muted" style="padding-top:15px;">멤버를 인원관리에 드래그 드롭하여 제외할 수 있습니다.</div>
                </div>
            </div>

            <!-- Right: Roster + IO -->
            <div class="panel">
                <div class="hd">
                    <div class="title">인원 관리</div>
                </div>
                <div class="bd">
                    <div class="listbar manage" style="gap:10px;align-items:center;flex-wrap:wrap;padding-bottom:12px;">
                        <input class="grow" id="nameInput" type="text" placeholder="이름 (최대 16자)" />
                        <input style="width:120px" id="scoreInput" type="number" placeholder="초기 점수" value="1000" />
                        <label class="muted">주라인
                            <select id="linePrimaryInput" class="line-select">
                                <option value="A" selected>All</option>
                                <option value="T">Top</option>
                                <option value="J">Jungle</option>
                                <option value="M">Mid</option>
                                <option value="B">Bottom</option>
                                <option value="S">Supporter</option>
                            </select>
                        </label>
                        <label class="muted">부라인
                            <select id="lineSecondaryInput" class="line-select">
                                <option value="A" selected>All</option>
                                <option value="T">Top</option>
                                <option value="J">Jungle</option>
                                <option value="M">Mid</option>
                                <option value="B">Bottom</option>
                                <option value="S">Supporter</option>
                            </select>
                        </label>
                        <button class="btn" id="btnAdd">인원추가</button>

                    </div>

                    <!-- ▼ 이름 검색 바 추가 -->
                    <div class="listbar" style="gap:10px;align-items:center;padding-bottom:10px;">
                        <input id="rosterSearch" type="text" placeholder="이름 검색 (최소 1자)" style="width:220px" />
                        <button class="btn small ghost" id="rosterSearchClear" title="검색 지우기">지우기</button>
                        <span class="muted" id="rosterSearchCount">전체 0명</span>
                        <span class="muted" id="selectedNames" style="white-space:nowrap;"></span>
                    </div>
                    <!-- ▲ 이름 검색 바 -->

                    <div class="rosterTable" id="managePanel">
                        <table class="rhead" style="padding-left : 10px; padding-right:15px;">
                            <colgroup>
                                <col style="width:44px" />
                                <col style="width:180px" />
                                <col style="width:110px" />
                                <col style="width:60px" />
                                <col style="width:60px" />
                                <col style="width:90px" />
                                <col style="width:50px" />
                            </colgroup>
                            <thead>
                                <tr>
                                    <th><input type="checkbox" id="checkAll"></th>
                                    <th class="sortable" data-sort="name">이름 <span class="sort-ind"></span></th>
                                    <th class="sortable" data-sort="line">라인<br><span class="muted"
                                            style="font-weight:400;">주/부</span> <span class="sort-ind"></span></th>
                                    <th class="sortable" data-sort="score">점수 <span class="sort-ind"></span></th>
                                    <th class="sortable" data-sort="games">판수 <span class="sort-ind"></span></th>
                                    <th class="sortable" data-sort="wl">승/패 <span class="sort-ind"></span></th>
                                    <th class="sortable" data-sort="wr">승률 <span class="sort-ind"></span></th>
                                </tr>
                            </thead>
                        </table>
                        <div class="rscroll">
                            <table class="rbody">
                                <colgroup>
                                    <col style="width:44px" />
                                    <col style="width:180px" />
                                    <col style="width:110px" />
                                    <col style="width:60px" />
                                    <col style="width:60px" />
                                    <col style="width:90px" />
                                    <col style="width:50px" />
                                </colgroup>
                                <tbody id="rosterBody"></tbody>
                            </table>
                        </div>
                    </div>
                    <div class="bar">
                        <button class="btn primary" id="btnMakeTeams">선택한 인원으로 팀 짜기</button>
                        <button class="btn ghost" id="btnToTeam1">선택 → 1팀</button>
                        <button class="btn ghost" id="btnToTeam2">선택 → 2팀</button>
                        <button class="btn ghost" id="btnRemoveFromTeams">선택한 인원을 팀에서 제거</button>
                        <div class="muted">멤버를 팀에 드래그 드롭하여 추가할 수 있습니다.</div>
                    </div>
                    <div class="listbar" style="padding-bottom:12px">
                        <button class="btn warn" id="btnDelete">인원 삭제(선택)</button>
                        <button class="btn" id="btnSave">텍스트로 저장</button> <span class="muted">현재 멤버 목록을 저장하여 불러올 수
                            있습니다.</span>
                    </div>
                    <div class="listbar" style="padding-bottom:12px">
                        <input id="fileInput" type="file" accept=".txt,.json" />
                        <button class="btn" id="btnLoad">불러오기</button>
                        <span class="muted">파일을 인원관리 리스트에 드래그하여 불러올 수 있습니다.</span>
                        <div class="muted" style="padding-top:15px;">
                            티어 예시 (400점 단위):<br>
                            Iron: 0–399<br>
                            Bronze: 400–799<br>
                            Silver: 800–1199<br>
                            Gold: 1200–1599<br>
                            Platinum: 1600–1999<br>
                            Emerald: 2000–2399<br>
                            Diamond: 2400–2799<br>
                            Master: 2800–3199<br>
                            Grandmaster: 3200–3599<br>
                            Challenger: 3600+
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="footer-note">
            오류 및 문의사항 : <span class="email-text">dosirak2332@daum.net</span>
        </div>
    </div>

    <script>
        /* =========================
            상태/상수/유틸 (필요한 것만)
        ========================= */
        const STORAGE_KEY = 'team_roster_v1', WIN_BONUS_KEY = 'win_bonus_v1', MODE_KEY = 'scoring_mode_v1', ELO_K_KEY = 'elo_k_v1';
        let roster = [];
        let currentTeams = { team1: [], team2: [] };
        let teamHistory = []; const HISTORY_LIMIT = 5;
        let lastTeams = { team1: [], team2: [] };

        const uid = () => Math.random().toString(36).slice(2, 10);
        const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
        const avg = a => a.length ? (a.reduce((s, x) => s + x, 0) / a.length) : 0;
        const isPlacement = g => (Number(g) || 0) <= 10;
        const winRate = p => { const w = +p.wins || 0, l = +p.losses || 0, t = w + l; return t ? Math.round((w / t) * 100) : 0 };
        const wrClass = r => r >= 53 ? 'wr-good' : (r <= 47 ? 'wr-bad' : '');
        const LINES = ['T', 'J', 'M', 'B', 'S', 'A'];
        const LINE_TITLE = { T: 'Top', J: 'Jungle', M: 'Mid', B: 'Bottom', S: 'Supporter', A: 'All' };
        const normLine = v => { v = String(v || 'A').toUpperCase(); return LINES.includes(v) ? v : 'A'; };
        const linePair = p => `${normLine(p.mainLine)}/${normLine(p.subLine)}`;
        const escapeHtml = s => String(s || '').replace(/[&<>"']/g, ch => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "'": "&#039;" }[ch]));

        function pushHistory(split) {
            teamHistory.unshift({ team1: (split.team1 || []).slice(), team2: (split.team2 || []).slice() });
            if (teamHistory.length > HISTORY_LIMIT) teamHistory.pop();
        }

        /* ============ 다양성(스왑 고려) ============ */
        function countSameSideEither(t1Ids, t2Ids, base = lastTeams) {
            const last1 = new Set(base.team1 || []), last2 = new Set(base.team2 || []);
            let c1 = 0; for (const id of t1Ids) if (last1.has(id)) c1++; for (const id of t2Ids) if (last2.has(id)) c1++;
            let c2 = 0; for (const id of t1Ids) if (last2.has(id)) c2++; for (const id of t2Ids) if (last1.has(id)) c2++;
            return Math.max(c1, c2);
        }
        function countSameSideMultiEither(t1Ids, t2Ids, histories = teamHistory.length ? teamHistory : [lastTeams]) {
            let m = 0; for (const h of histories) { const c = countSameSideEither(t1Ids, t2Ids, h); if (c > m) m = c; } return m;
        }

        /* ============ 저장/로드 ============ */
        function saveLocal() { localStorage.setItem(STORAGE_KEY, JSON.stringify(roster)); }
        function loadLocal() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if (raw) {
                    const data = JSON.parse(raw);
                    if (Array.isArray(data)) {
                        roster = data.filter(x => x && x.name).map(x => ({
                            id: x.id || uid(),
                            name: String(x.name || '').trim(),
                            score: +x.score || 0,
                            games: Math.max(0, Math.floor(+x.games || 0)),
                            wins: Math.max(0, Math.floor(+x.wins || 0)),
                            losses: Math.max(0, Math.floor(+x.losses || 0)),
                            mainLine: normLine(x.mainLine),
                            subLine: normLine(x.subLine),
                        }));
                    }
                }
            } catch (e) { console.warn(e); }
        }

        /* ============ DOM ============ */
        const rosterBody = document.getElementById('rosterBody');
        const checkAll = document.getElementById('checkAll');
        const nameInput = document.getElementById('nameInput');
        const scoreInput = document.getElementById('scoreInput');
        const winBonusInput = document.getElementById('winBonusInput');
        const scoringModeSel = document.getElementById('scoringMode');
        const eloKInput = document.getElementById('eloK');
        const fileInput = document.getElementById('fileInput');
        const team1UL = document.getElementById('team1');
        const team2UL = document.getElementById('team2');
        const team1Box = document.getElementById('team1Box');
        const team2Box = document.getElementById('team2Box');
        const linePrimaryInput = document.getElementById('linePrimaryInput');
        const lineSecondaryInput = document.getElementById('lineSecondaryInput');
        const balanceModeSel = document.getElementById('balanceMode');
        const teamSortSel = document.getElementById('teamSort');
        const mmrToleranceInput = document.getElementById('mmrTolerance');
        const mixStrengthSel = document.getElementById('mixStrength');
        const rosterSearchInput = document.getElementById('rosterSearch');
        const rosterSearchClear = document.getElementById('rosterSearchClear');
        const rosterSearchCount = document.getElementById('rosterSearchCount');
        const selectedNamesEl = document.getElementById('selectedNames');
        const eloKWrap = document.getElementById('eloKWrap');
        const winBonusWrap = document.getElementById('winBonusWrap');
        const managePanel = document.getElementById('managePanel');

        let rosterSortKey = 'name';   // name | line | score | wl | wr
        let rosterSortAsc = true;     // true: 오름차순, false: 내림차순

        let rosterSearchTerm = '';

        const lineOptionsHTML = (sel) => ['T', 'J', 'M', 'B', 'S', 'A'].map(k => `<option value="${k}" ${sel === k ? 'selected' : ''} title="${LINE_TITLE[k]}">${k}</option>`).join('');

        /* ============ 라인 배정 ============ */
        function assignRoles(team) {
            const roles = ['T', 'J', 'M', 'B', 'S'], used = new Set(), assignment = {}; let primaryAssigned = 0;
            for (const r of roles) { const i = team.findIndex(p => !used.has(p.id) && normLine(p.mainLine) === r); if (i >= 0) { used.add(team[i].id); assignment[r] = team[i].id; primaryAssigned++; } }
            for (const r of roles) { if (assignment[r]) continue; const i = team.findIndex(p => !used.has(p.id) && normLine(p.subLine) === r); if (i >= 0) { used.add(team[i].id); assignment[r] = team[i].id; } }
            for (const r of roles) { if (assignment[r]) continue; const i = team.findIndex(p => !used.has(p.id) && (normLine(p.mainLine) === 'A' || normLine(p.subLine) === 'A')); if (i >= 0) { used.add(team[i].id); assignment[r] = team[i].id; } }
            return { coveredRoles: Object.keys(assignment).length, primaryAssigned };
        }

        /* ============ 평가 함수(핵심) ============ */
        function scoreSplit(t1, t2, mode, allowDiff) {
            const m1 = avg(t1.map(p => p.score)), m2 = avg(t2.map(p => p.score)), diff = Math.abs(m1 - m2);
            const sdev = a => { const m = avg(a); return a.length ? Math.sqrt(a.reduce((s, x) => s + (x - m) * (x - m), 0) / a.length) : 0 };
            const s1 = sdev(t1.map(p => p.score)), s2 = sdev(t2.map(p => p.score));

            let a1 = { coveredRoles: 0, primaryAssigned: 0 }, a2 = { coveredRoles: 0, primaryAssigned: 0 };
            if (mode === 'prefer_line') { a1 = assignRoles(t1); a2 = assignRoles(t2); }

            // 파라미터
            let wCover = 0, wPrimary = 0, jitterAmp = 1.5, diversityW = 1.5, mmrDiv = 180;
            if (mode === 'prefer_line') { wCover = 12; wPrimary = 4; jitterAmp = 0.8; diversityW = 1.2; mmrDiv = 120; }
            else { jitterAmp = 4.0; diversityW = 4.0; mmrDiv = 200; }

            // ★ 라인 공정성 보너스: 주라인 더 많은 팀의 평균이 더 낮을수록 +
            let lineFairBonus = 0;
            if (mode === 'prefer_line') {
                const gap = (a1.primaryAssigned || 0) - (a2.primaryAssigned || 0); // +면 팀1이 주라인多
                if (gap !== 0) {
                    const favSign = Math.sign(gap);                  // +1: 팀1 유리
                    const fairRaw = favSign * (m2 - m1);            // 유리팀 평균이 낮을수록 +
                    const wFair = 0.25;                             // 튜닝
                    lineFairBonus = clamp(fairRaw * wFair * Math.abs(gap), -60, 60);
                }
            }

            // ★ 승률 보정 보너스: 평균 승률 낮은 팀의 평균 MMR이 더 높을수록 +
            let wrCompBonus = 0;
            {
                const wr1 = avg(t1.map(winRate)), wr2 = avg(t2.map(winRate));
                const wrGap = wr2 - wr1;                            // >0: 팀1 승률 낮음
                if (Math.abs(wrGap) > 0) {
                    const favSign = Math.sign(wrGap);               // +1: 팀1 낮은 승률
                    const compRaw = favSign * (m1 - m2);            // 낮은 승률 팀 평균이 높을수록 +
                    const wWR = 0.30;                               // 튜닝
                    const wrScale = clamp(Math.abs(wrGap) / 20, 0, 1); // 0~20% 구간 가중
                    wrCompBonus = clamp(compRaw * wWR * (1 + wrScale * 0.5), -80, 80);
                }
            }

            // 페널티들
            const over = Math.max(0, diff - allowDiff);
            const mmrPenalty = (over * over) / mmrDiv;
            const spreadPenalty = Math.abs(s1 - s2) * 0.18;

            const ids1 = t1.map(p => p.id), ids2 = t2.map(p => p.id);
            const sameSideMax = countSameSideMultiEither(ids1, ids2);
            const total = (ids1.length + ids2.length) || 1;
            const identicalPenalty = (sameSideMax === total) ? 1e6 : 0;
            const diversityPenalty = sameSideMax * diversityW;

            // 하드 가드: 허용치 초과 강제 제재
            const hardPenalty = over > 0 ? over * over * 250 : 0;

            const jitter = (Math.random() - 0.5) * jitterAmp;

            return ((a1.coveredRoles + a2.coveredRoles) * wCover + (a1.primaryAssigned + a2.primaryAssigned) * wPrimary
                + lineFairBonus + wrCompBonus)
                - mmrPenalty - spreadPenalty - diversityPenalty - identicalPenalty - hardPenalty
                + jitter;
        }

        /* ============ 탐색/보정 ============ */
        function improveBySwaps(pick, map, mode, allowDiff, rounds = 260, temp = 1.4, minChange = 2) {
            let best = JSON.parse(JSON.stringify(pick));
            let bestScore = scoreSplit(best.team1.map(id => map.get(id)), best.team2.map(id => map.get(id)), mode, allowDiff);
            let ids1 = best.team1.slice(), ids2 = best.team2.slice();

            for (let r = 0; r < rounds; r++) {
                const i = (Math.random() * ids1.length) | 0, j = (Math.random() * ids2.length) | 0;
                [ids1[i], ids2[j]] = [ids2[j], ids1[i]];
                const t1 = ids1.map(id => map.get(id)), t2 = ids2.map(id => map.get(id));
                let sc = scoreSplit(t1, t2, mode, allowDiff);

                const d1 = Math.abs(avg(t1.map(p => p.score)) - avg(t2.map(p => p.score)));
                if (d1 > allowDiff) sc -= (d1 - allowDiff) * 1e6;

                const changed = (ids1.length + ids2.length) - countSameSideEither(ids1, ids2, lastTeams);
                if (changed < minChange) sc -= (minChange - changed) * 15;

                const delta = sc - bestScore;
                if (delta >= 0 || Math.exp(delta / Math.max(0.001, temp)) > Math.random()) {
                    bestScore = sc; best.team1 = ids1.slice(); best.team2 = ids2.slice();
                } else {
                    [ids1[i], ids2[j]] = [ids2[j], ids1[i]];
                }
                temp *= 0.996;
            }
            return best;
        }
        function teamMeanByIds(ids, map) { if (!ids.length) return 0; let s = 0; for (const id of ids) s += map.get(id).score; return s / ids.length; }
        function mmrDiffOfPick(pick, map) { return Math.abs(teamMeanByIds(pick.team1, map) - teamMeanByIds(pick.team2, map)); }
        function reduceMMRGap(pick, map, targetDiff, maxIters = 120) {
            let iter = 0;
            while (iter++ < maxIters) {
                const before = mmrDiffOfPick(pick, map); if (before <= targetDiff) break;
                let bestGain = 0, bi = -1, bj = -1;
                for (let i = 0; i < pick.team1.length; i++) {
                    for (let j = 0; j < pick.team2.length; j++) {
                        const a = pick.team1[i], b = pick.team2[j];
                        [pick.team1[i], pick.team2[j]] = [b, a];
                        const after = mmrDiffOfPick(pick, map);
                        [pick.team1[i], pick.team2[j]] = [a, b];
                        const gain = before - after;
                        if (gain > bestGain) { bestGain = gain; bi = i; bj = j; }
                    }
                }
                if (bestGain > 0) { const a = pick.team1[bi], b = pick.team2[bj];[pick.team1[bi], pick.team2[bj]] = [b, a]; } else break;
            }
            return pick;
        }

        /* ============ 팀 빌드 ============ */
        function shuffle(a) { for (let i = a.length - 1; i > 0; i--) { const j = (Math.random() * (i + 1)) | 0;[a[i], a[j]] = [a[j], a[i]] } }
        function buildBalancedTeams(players, mode = 'prefer_line') {
            const n = players.length, half = n / 2, idx = [...Array(n).keys()];
            const allowDiff = Math.max(0, Math.round(Number(mmrToleranceInput?.value || 120)));
            const strength = (mixStrengthSel?.value || 'normal');

            let attemptsBase, swapBase, tempBase, minChangeDiv;
            if (mode === 'prefer_line') { attemptsBase = 900; swapBase = 320; tempBase = 1.5; minChangeDiv = 4; }
            else { attemptsBase = 2000; swapBase = 800; tempBase = 3.0; minChangeDiv = 2; }

            const attempts = Math.min((strength === 'strong' ? attemptsBase * 2 : attemptsBase) * n, 30000);
            const swapRounds = (strength === 'strong' ? Math.round(swapBase * 1.4) : swapBase);
            const initTemp = (strength === 'strong' ? tempBase * 1.2 : tempBase);
            const minChange = Math.max(2, Math.floor(n / minChangeDiv));

            let evalPlayers = players;
            if (mode === 'prefer_mmr') evalPlayers = players.map(p => ({ ...p, score: p.score + (Math.random() - 0.5) * 20 }));
            const map = new Map(evalPlayers.map(p => [p.id, p]));

            let best = null, bestScore = -Infinity;
            for (let a = 0; a < attempts; a++) {
                shuffle(idx);
                const t1 = idx.slice(0, half).map(i => evalPlayers[i]);
                const t2 = idx.slice(half).map(i => evalPlayers[i]);
                let sc = scoreSplit(t1, t2, mode, allowDiff);

                const d0 = Math.abs(avg(t1.map(p => p.score)) - avg(t2.map(p => p.score)));
                if (d0 > allowDiff) sc -= (d0 - allowDiff) * 1e6;

                const same = countSameSideMultiEither(t1.map(p => p.id), t2.map(p => p.id));
                const changed = (t1.length + t2.length) - same;
                if (changed < minChange) sc -= (minChange - changed) * 20;

                if (sc > bestScore) { bestScore = sc; best = { team1: t1.map(p => p.id), team2: t2.map(p => p.id) }; }
            }
            if (!best) return { team1: evalPlayers.slice(0, half).map(p => p.id), team2: evalPlayers.slice(half).map(p => p.id) };

            best = improveBySwaps(best, map, mode, allowDiff, swapRounds, initTemp, minChange);

            // 다양성 최소 보장
            const total = best.team1.length + best.team2.length;
            let changed = total - countSameSideMultiEither(best.team1, best.team2);
            if (changed < minChange) {
                const need = minChange - changed;
                for (let k = 0; k < need; k++) {
                    const i = (Math.random() * best.team1.length) | 0, j = (Math.random() * best.team2.length) | 0;
                    [best.team1[i], best.team2[j]] = [best.team2[j], best.team1[i]];
                }
                if (mode === 'prefer_mmr') {
                    for (let k = 0; k < best.team1.length; k++) {
                        if (Math.random() < 0.3) {
                            const i = (Math.random() * best.team1.length) | 0, j = (Math.random() * best.team2.length) | 0;
                            [best.team1[i], best.team2[j]] = [best.team2[j], best.team1[i]];
                        }
                    }
                }
            }

            // 허용치 충족 보정
            best = reduceMMRGap(best, map, allowDiff);
            return best;
        }

        function updateRosterHeaderIndicators() {
            const ths = document.querySelectorAll('.rhead thead th.sortable');
            ths.forEach(th => {
                const key = th.getAttribute('data-sort');
                const ind = th.querySelector('.sort-ind');
                if (!ind) return;
                if (key === rosterSortKey) {
                    ind.textContent = rosterSortAsc ? '▲' : '▼';
                    ind.style.opacity = '1';
                } else {
                    ind.textContent = '';
                    ind.style.opacity = '.5';
                }
            });
        }

        /* ============ 렌더: 로스터/팀 ============ */
        function renderRoster() {
            const key = rosterSortKey;
            const asc = rosterSortAsc ? 1 : -1;
            const term = rosterSearchTerm.trim().toLowerCase();

            const sorted = roster.slice().sort((a, b) => {
                const byName = a.name.localeCompare(b.name, 'ko');
                if (key === 'name') return asc * byName;

                if (key === 'line') {
                    const la = (normLine(a.mainLine) + '/' + normLine(a.subLine));
                    const lb = (normLine(b.mainLine) + '/' + normLine(b.subLine));
                    const cmp = la.localeCompare(lb);
                    return asc * (cmp || byName);
                }

                if (key === 'score') {
                    const cmp = (a.score - b.score);
                    return asc * (cmp || byName);
                }

                if (key === 'wl') {
                    const wa = +a.wins || 0, wb = +b.wins || 0;
                    const la = +a.losses || 0, lb = +b.losses || 0;
                    const cmp = (wa - wb) || (lb - la); // 승 많을수록↑, 승 같으면 패 적을수록↑
                    return asc * (cmp || byName);
                }

                if (key === 'wr') {
                    const ra = winRate(a), rb = winRate(b);
                    const cmp = (ra - rb);
                    return asc * (cmp || byName);
                }

                if (key === 'games') {
                    const ga = +a.games || 0, gb = +b.games || 0;
                    const cmp = (ga - gb);
                    return asc * (cmp || byName);
                }

                return byName;
            });
            const list = term ? sorted.filter(p => p.name.toLowerCase().includes(term)) : sorted;

            if (rosterSearchCount) {
                rosterSearchCount.textContent = term ? `검색 결과 ${list.length}명 / 전체 ${roster.length}명` : `전체 ${roster.length}명`;
            }

            rosterBody.innerHTML = '';
            list.forEach(p => {
                const tr = document.createElement('tr'); tr.setAttribute('draggable', 'true'); tr.dataset.id = p.id;
                const rate = winRate(p);
                const p1 = normLine(p.mainLine || 'A'), p2 = normLine(p.subLine || 'A');
                const safe = escapeHtml(p.name);
                const highlighted = term ? safe.replace(new RegExp(`(${term.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\$&')})`, 'gi'), '<mark>$1</mark>') : safe;
                tr.innerHTML = `
                    <td><input type="checkbox" data-id="${p.id}" class="rowcheck"></td>
                    <td class="cell-name" data-id="${p.id}" title="더블클릭으로 이름 수정">${highlighted}</td>
                    <td class="cell-line">
                        <select class="line-select cell-line1" data-id="${p.id}" title="주 라인">${lineOptionsHTML(p1)}</select>
                        <span class="line-slash">/</span>
                        <select class="line-select cell-line2" data-id="${p.id}" title="부 라인">${lineOptionsHTML(p2)}</select>
                    </td>
                    <td class="tabnum"><input data-id="${p.id}" class="cell-score" type="number" value="${p.score}" /></td>
                    <td class="tabnum"><input data-id="${p.id}" class="cell-games" type="number" min="0" value="${p.games || 0}" /></td>
                    <td class="tabnum"><span class="wl-badge" data-id="${p.id}">${p.wins || 0}/${p.losses || 0}</span></td>
                    <td class="tabnum"><span class="wr-badge ${wrClass(rate)}" data-id="${p.id}">${rate}%</span></td>
                `;
                rosterBody.appendChild(tr);
            });
            if (checkAll) checkAll.checked = false;
            updateSelectedUI();
            updateRosterHeaderIndicators();
        }


        function renderTeams() {
            const t1 = currentTeams.team1.map(id => roster.find(p => p.id === id)).filter(Boolean);
            const t2 = currentTeams.team2.map(id => roster.find(p => p.id === id)).filter(Boolean);
            const a1 = avg(t1.map(p => p.score)), a2 = avg(t2.map(p => p.score));
            document.getElementById('avg1').innerHTML = `평균 <span class="${a1 >= a2 ? 'good' : 'bad'}">${a1.toFixed(1)}</span>`;
            document.getElementById('avg2').innerHTML = `평균 <span class="${a2 >= a1 ? 'good' : 'bad'}">${a2.toFixed(1)}</span>`;

            const sortKey = (teamSortSel && teamSortSel.value) || 'name';
            const cmp = (a, b) => {
                if (sortKey === 'name') return a.name.localeCompare(b.name, 'ko');
                if (sortKey === 'line') return linePair(a).localeCompare(linePair(b));
                if (sortKey === 'wr') return (winRate(b) - winRate(a)) || a.name.localeCompare(b.name, 'ko');
                if (sortKey === 'score') return (b.score - a.score) || a.name.localeCompare(b.name, 'ko');
                return 0;
            };
            t1.sort(cmp); t2.sort(cmp);

            team1UL.innerHTML = ''; team2UL.innerHTML = '';
            const makeRow = p => {
                const wr = winRate(p);
                const li = document.createElement('li');
                li.className = 'teamRow'; li.setAttribute('draggable', 'true'); li.dataset.id = p.id;
                li.innerHTML = `
                    <span class="cell-name" title="${escapeHtml(p.name)}">${escapeHtml(p.name)}</span>
                    <span class="cell-line tabnum" title="${LINE_TITLE[normLine(p.mainLine)]}/${LINE_TITLE[normLine(p.subLine)]}">${linePair(p)}</span>
                    <span class="cell-wr tabnum ${wrClass(wr)}">${wr}%</span>
                    <span class="cell-score tabnum">${p.score}</span>
                `;
                li.addEventListener('dragstart', e => { e.dataTransfer.setData('text/plain', p.id); e.dataTransfer.effectAllowed = 'move'; });
                return li;
            };
            t1.forEach(p => team1UL.appendChild(makeRow(p)));
            t2.forEach(p => team2UL.appendChild(makeRow(p)));
        }

        /* ============ 드래그/드롭 ============ */
        function bindDropTarget(ulEl, boxEl, teamNo) {
            const onDragOver = e => { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; };
            const onDragEnter = () => boxEl.classList.add('drop-target');
            const onDragLeave = e => { if (!boxEl.contains(e.relatedTarget)) boxEl.classList.remove('drop-target'); };
            const onDrop = e => { e.preventDefault(); boxEl.classList.remove('drop-target'); const id = e.dataTransfer.getData('text/plain'); if (!id) return; addIdToTeam(teamNo, id); };
            ulEl.addEventListener('dragover', onDragOver);
            ulEl.addEventListener('dragenter', onDragEnter);
            ulEl.addEventListener('dragleave', onDragLeave);
            ulEl.addEventListener('drop', onDrop);
            boxEl.addEventListener('dragover', onDragOver);
            boxEl.addEventListener('dragenter', onDragEnter);
            boxEl.addEventListener('dragleave', onDragLeave);
            boxEl.addEventListener('drop', onDrop);
        }
        bindDropTarget(team1UL, team1Box, 1);
        bindDropTarget(team2UL, team2Box, 2);

        rosterBody.addEventListener('dragover', e => { e.preventDefault(); rosterBody.classList.add('drop-target'); });
        rosterBody.addEventListener('dragleave', e => { if (!rosterBody.contains(e.relatedTarget)) rosterBody.classList.remove('drop-target'); });
        rosterBody.addEventListener('drop', e => {
            e.preventDefault(); rosterBody.classList.remove('drop-target');
            const id = e.dataTransfer.getData('text/plain'); if (!id) return;
            currentTeams.team1 = currentTeams.team1.filter(x => x !== id);
            currentTeams.team2 = currentTeams.team2.filter(x => x !== id);
            renderTeams();
        });
        rosterBody.addEventListener('dragstart', e => {
            // 입력 요소에서 시작하면 드래그 취소 (편집 방해 방지)
            const tag = e.target.tagName;
            if (tag === 'INPUT' || tag === 'SELECT' || tag === 'BUTTON' || tag === 'A') return;

            const tr = e.target.closest('tr[draggable="true"]');
            if (!tr) return;

            const id = tr.dataset.id;
            if (id && e.dataTransfer) {
                e.dataTransfer.setData('text/plain', id);
                e.dataTransfer.effectAllowed = 'move';
            }
        });

        function addIdToTeam(teamNo, id) {
            if (!id) return;
            const other = teamNo === 1 ? currentTeams.team2 : currentTeams.team1;
            const target = teamNo === 1 ? currentTeams.team1 : currentTeams.team2;
            const otherSet = new Set(other), targetSet = new Set(target);
            if (otherSet.has(id)) otherSet.delete(id);
            targetSet.add(id);
            if (teamNo === 1) { currentTeams.team2 = [...otherSet]; currentTeams.team1 = [...targetSet]; }
            else { currentTeams.team1 = [...otherSet]; currentTeams.team2 = [...targetSet]; }
            renderTeams();
        }

        /* ============ 이벤트/액션 ============ */
        // 로스터 셀 변경
        rosterBody.addEventListener('change', e => {
            const t = e.target, id = t.dataset.id, p = roster.find(x => x.id === id); if (!p) return;
            if (t.classList.contains('rowcheck')) { updateSelectedUI(); return; }
            if (t.classList.contains('cell-line1')) p.mainLine = normLine(t.value);
            else if (t.classList.contains('cell-line2')) p.subLine = normLine(t.value);
            else if (t.classList.contains('cell-score')) p.score = isFinite(+t.value) ? +t.value : p.score;
            else if (t.classList.contains('cell-games')) p.games = Math.max(0, Math.floor(+t.value || 0));
            saveLocal(); renderTeams();
        });

        // 로스터 승패 초기화
        rosterBody.addEventListener('dblclick', e => {
            const wl = e.target.closest('.wl-badge'); if (!wl) return;
            const p = roster.find(x => x.id === wl.dataset.id); if (!p) return;
            if (confirm(`"${p.name}"의 승패를 초기화하시겠습니까?`)) {
                p.wins = 0; p.losses = 0; saveLocal(); renderRoster(); renderTeams();
            }
        });

        // 전체선택
        checkAll.addEventListener('change', () => {
            document.querySelectorAll('.rowcheck').forEach(cb => cb.checked = checkAll.checked);
            updateSelectedUI(); // 추가
        });

        // 검색
        let _searchTimer = null;
        function setSearchTerm(v) { rosterSearchTerm = (v || '').slice(0, 50); renderRoster(); }
        if (rosterSearchInput) {
            rosterSearchInput.addEventListener('input', (e) => {
                const v = e.target.value;
                clearTimeout(_searchTimer);
                _searchTimer = setTimeout(() => { setSearchTerm(v); updateSelectedUI(); }, 120);
            });
        }
        if (rosterSearchClear) {
            rosterSearchClear.addEventListener('click', () => {
                rosterSearchInput.value = '';
                setSearchTerm('');
                rosterSearchInput.focus();
                updateSelectedUI();
            });
        }

        function getSelectedIds() {
            return [...document.querySelectorAll('.rowcheck:checked')].map(cb => cb.dataset.id);
        }

        function updateSelectedUI() {
            const ids = getSelectedIds();
            const names = ids
                .map(id => (roster.find(p => p.id === id) || {}).name)
                .filter(Boolean);

            // 기존 "전체/검색 결과" 문구는 그대로 유지
            const total = roster.length;
            if (rosterSearchCount) {
                // 현재 화면에 표시된 행 수(검색 적용 후) 반영
                const visibleCount = document.querySelectorAll('#rosterBody tr').length;
                const term = (rosterSearchTerm || '').trim();
                const base = term
                    ? `검색 결과 ${visibleCount}명 / 전체 ${total}명`
                    : `전체 ${total}명`;
                rosterSearchCount.textContent = base;
            }

            // 선택 요약 출력 (이름은 많으면 접기)
            if (selectedNamesEl) {
                if (ids.length) {
                    const MAX = 8;
                    const shown = names.slice(0, MAX);
                    const more = names.length - shown.length;
                    selectedNamesEl.textContent =
                        ` | 선택 ${ids.length}명`;
                } else {
                    selectedNamesEl.textContent = '';
                }
            }
        }

        function toggleScoringControls() {
            const mode = (scoringModeSel && scoringModeSel.value) || 'elo';
            if (mode === 'elo') {
                if (eloKWrap) eloKWrap.style.display = '';
                if (winBonusWrap) winBonusWrap.style.display = 'none';
            } else { // fixed
                if (eloKWrap) eloKWrap.style.display = 'none';
                if (winBonusWrap) winBonusWrap.style.display = '';
            }
        }

        // 인원 추가/삭제
        document.getElementById('btnAdd').addEventListener('click', () => {
            let name = (nameInput.value || '').trim(); const score = +scoreInput.value || 0;
            const pLine = normLine(linePrimaryInput.value || 'A'), sLine = normLine(lineSecondaryInput.value || 'A');
            if (!name) { alert('이름을 입력하세요.'); nameInput.focus(); return; }
            if (name.length > 16) { alert('이름은 최대 16자까지만 가능합니다.'); name = name.slice(0, 16); }
            roster.push({ id: uid(), name, score, games: 0, wins: 0, losses: 0, mainLine: pLine, subLine: sLine });
            saveLocal(); renderRoster(); renderTeams();
            nameInput.value = ''; scoreInput.value = '1000'; linePrimaryInput.value = 'A'; lineSecondaryInput.value = 'A'; nameInput.focus();
        });

        document.getElementById('btnDelete').addEventListener('click', () => {
            const ids = new Set([...document.querySelectorAll('.rowcheck:checked')].map(cb => cb.dataset.id));
            if (!ids.size) { alert('삭제할 인원을 선택하세요.'); return; }
            const names = roster.filter(p => ids.has(p.id)).map(p => p.name).join(', ');
            if (!confirm(`정말 삭제하시겠습니까?\n${names}`)) return;
            roster = roster.filter(p => !ids.has(p.id));
            currentTeams.team1 = currentTeams.team1.filter(id => !ids.has(id));
            currentTeams.team2 = currentTeams.team2.filter(id => !ids.has(id));
            saveLocal(); renderRoster(); renderTeams();
        });

        // 저장/불러오기
        document.getElementById('btnSave').addEventListener('click', () => {
            const blob = new Blob([JSON.stringify(roster, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');

            const now = new Date();
            const pad = n => String(n).padStart(2, '0');

            // YYMMDD_HHMM 구성
            const yy = String(now.getFullYear()).slice(-2);
            const mm = pad(now.getMonth() + 1);
            const dd = pad(now.getDate());
            const HH = pad(now.getHours());
            const MM = pad(now.getMinutes());

            a.href = url;
            a.download = `member_${yy}${mm}${dd}_${HH}${MM}.txt`; // 예: member_250926_1320.txt
            a.click();
            URL.revokeObjectURL(url);
        });

        window.addEventListener('dragover', e => e.preventDefault());
        window.addEventListener('drop', e => {
            // managePanel 외부에 드롭하면 네비게이션 방지
            if (!(e.target && managePanel && managePanel.contains(e.target))) {
                e.preventDefault();
            }
        });

        // 패널 하이라이트 on/off
        ['dragenter', 'dragover'].forEach(ev => {
            managePanel.addEventListener(ev, e => {
                if (!e.dataTransfer || !Array.from(e.dataTransfer.types || []).includes('Files')) return;
                e.preventDefault(); e.stopPropagation();
                managePanel.classList.add('dragover');
            });
        });
        ['dragleave', 'drop'].forEach(ev => {
            managePanel.addEventListener(ev, e => {
                e.preventDefault(); e.stopPropagation();
                managePanel.classList.remove('dragover');
            });
        });

        // 실제 드롭 처리
        managePanel.addEventListener('drop', e => {
            const files = e.dataTransfer?.files;
            if (!files || !files.length) return;
            const f = files[0];

            // txt/json만 받기 (원하면 제거 가능)
            if (!/(\.txt|\.json)$/i.test(f.name)) {
                alert('txt 또는 json 파일만 지원합니다.');
                return;
            }

            const reader = new FileReader();
            reader.onload = () => loadFromText(String(reader.result || ''));
            reader.readAsText(f, 'utf-8');
        });

        function loadFromText(text) {
            try {
                let data;
                const trimmed = String(text || '').trim();
                if (trimmed.startsWith('[') || trimmed.startsWith('{')) {
                    data = JSON.parse(trimmed);
                } else {
                    // 텍스트(CSV풍): 이름, 점수, 판수, 승, 패, 주라인, 부라인
                    data = trimmed.split(/\r?\n/).map(line => {
                        if (!line.trim()) return null;
                        const a = line.split(',').map(s => s.trim());
                        if (!a[0]) return null;
                        return {
                            name: a[0], score: +a[1] || 0,
                            games: a[2] ? Math.max(0, Math.floor(+a[2] || 0)) : 0,
                            wins: a[3] ? Math.max(0, Math.floor(+a[3] || 0)) : 0,
                            losses: a[4] ? Math.max(0, Math.floor(+a[4] || 0)) : 0,
                            mainLine: normLine(a[5] || 'A'),
                            subLine: normLine(a[6] || 'A')
                        };
                    }).filter(Boolean);
                }
                if (!Array.isArray(data)) data = [data];
                roster = data.map(it => ({
                    id: uid(),
                    name: String(it.name || '').slice(0, 16),
                    score: +it.score || 0,
                    games: Math.max(0, Math.floor(+it.games || 0)),
                    wins: Math.max(0, Math.floor(+it.wins || 0)),
                    losses: Math.max(0, Math.floor(+it.losses || 0)),
                    mainLine: normLine(it.mainLine),
                    subLine: normLine(it.subLine)
                })).filter(x => x.name);

                const valid = new Set(roster.map(p => p.id));
                currentTeams.team1 = currentTeams.team1.filter(id => valid.has(id));
                currentTeams.team2 = currentTeams.team2.filter(id => valid.has(id));

                saveLocal(); renderRoster(); renderTeams();
            } catch (e) {
                console.error(e);
                alert('불러오기 실패: 파일 형식을 확인하세요.');
            }
        }


        document.getElementById('btnLoad').addEventListener('click', () => {
            const f = fileInput.files?.[0];
            if (!f) { alert('불러올 파일을 선택하세요.'); fileInput.click(); return; }
            const reader = new FileReader();
            reader.onload = () => loadFromText(String(reader.result || ''));
            reader.readAsText(f, 'utf-8');
        });

        // 팀 만들기/리메이크/정렬
        function teamsAlmostSame(a, b) {
            const A1 = new Set(a.team1), A2 = new Set(a.team2), tot = (a.team1.length + a.team2.length) || 1;
            let same = 0; for (const id of b.team1) if (A1.has(id)) same++; for (const id of b.team2) if (A2.has(id)) same++;
            let sameSwap = 0; for (const id of b.team1) if (A2.has(id)) sameSwap++; for (const id of b.team2) if (A1.has(id)) sameSwap++;
            return Math.max(same, sameSwap) / tot >= 0.85;
        }

        document.getElementById('btnMakeTeams').addEventListener('click', () => {
            const ids = [...document.querySelectorAll('.rowcheck:checked')].map(cb => cb.dataset.id);
            if (ids.length < 2 || ids.length % 2 !== 0) { alert('짝수 인원을 선택하세요. (현재 ' + ids.length + '명)'); return; }
            const players = ids.map(id => roster.find(p => p.id === id)).filter(Boolean);
            const mode = (balanceModeSel && balanceModeSel.value) || 'prefer_line';
            let pick = buildBalancedTeams(players, mode);
            if (teamsAlmostSame(pick, lastTeams) && mode !== 'prefer_line') {
                const bakT = mmrToleranceInput.value, bakS = mixStrengthSel.value;
                mmrToleranceInput.value = String(Math.floor(Number(bakT || 120) * 1.5)); mixStrengthSel.value = 'strong';
                pick = buildBalancedTeams(players, mode);
                mmrToleranceInput.value = bakT; mixStrengthSel.value = bakS;
            }
            currentTeams = pick; renderTeams(); lastTeams = JSON.parse(JSON.stringify(currentTeams));
        });

        document.getElementById('btnRemakeTeams').addEventListener('click', () => {
            const all = [...currentTeams.team1, ...currentTeams.team2];
            if (all.length < 2 || all.length % 2 !== 0) { alert('먼저 짝수 인원으로 팀을 만들어주세요. (현재 ' + all.length + '명)'); return; }
            const players = all.map(id => roster.find(p => p.id === id)).filter(Boolean);
            if (players.length !== all.length) { alert('일부 멤버가 목록에서 사라졌습니다. 다시 선택해서 팀을 만들어주세요.'); return; }
            currentTeams = buildBalancedTeams(players, (balanceModeSel && balanceModeSel.value) || 'prefer_line');
            renderTeams(); lastTeams = JSON.parse(JSON.stringify(currentTeams));
        });

        teamSortSel.addEventListener('change', renderTeams);

        document.getElementById('btnClearTeams').addEventListener('click', () => {
            currentTeams = { team1: [], team2: [] };
            lastTeams = { team1: [], team2: [] };
            renderTeams();
            document.getElementById('avg1').textContent = '평균 0';
            document.getElementById('avg2').textContent = '평균 0';
        });

        // 선택 이동/제거
        document.getElementById('btnToTeam1').addEventListener('click', () => {
            const ids = [...document.querySelectorAll('.rowcheck:checked')].map(cb => cb.dataset.id);
            if (!ids.length) { alert('팀에 넣을 인원을 체크하세요.'); return; }
            ids.forEach(id => addIdToTeam(1, id));
        });
        document.getElementById('btnToTeam2').addEventListener('click', () => {
            const ids = [...document.querySelectorAll('.rowcheck:checked')].map(cb => cb.dataset.id);
            if (!ids.length) { alert('팀에 넣을 인원을 체크하세요.'); return; }
            ids.forEach(id => addIdToTeam(2, id));
        });
        document.getElementById('btnRemoveFromTeams').addEventListener('click', () => {
            const ids = new Set([...document.querySelectorAll('.rowcheck:checked')].map(cb => cb.dataset.id));
            if (!ids.size) { alert('팀에서 제거할 인원을 체크하세요.'); return; }
            currentTeams.team1 = currentTeams.team1.filter(id => !ids.has(id));
            currentTeams.team2 = currentTeams.team2.filter(id => !ids.has(id));
            renderTeams();
        });

        // 승패 반영
        function confirmAndApply(winTeam) {
            const n1 = currentTeams.team1.length, n2 = currentTeams.team2.length;
            if (n1 === 0 || n2 === 0 || n1 !== n2) { alert('먼저 짝수 인원으로 팀을 만들어주세요.'); return; }
            const msg = `${winTeam === 1 ? '1팀 승리' : '2팀 승리'}로 점수를 반영할까요?`;
            if (confirm(msg)) applyResult(winTeam);
        }
        document.getElementById('btnWin1').addEventListener('click', () => confirmAndApply(1));
        document.getElementById('btnWin2').addEventListener('click', () => confirmAndApply(2));

        function applyResult(winTeam) {
            const ids1 = new Set(currentTeams.team1), ids2 = new Set(currentTeams.team2);
            if (ids1.size === 0 || ids2.size === 0 || ids1.size !== ids2.size) { alert('먼저 짝수 인원으로 팀을 만들어주세요.'); return; }
            const team1 = roster.filter(p => ids1.has(p.id)), team2 = roster.filter(p => ids2.has(p.id));
            const mode = (scoringModeSel && scoringModeSel.value) || 'fixed';

            if (mode === 'elo') {
                const R1 = avg(team1.map(p => p.score)), R2 = avg(team2.map(p => p.score));
                const E1 = 1 / (1 + Math.pow(10, (R2 - R1) / 400)), E2 = 1 - E1;
                const K = Math.round(Number(eloKInput && eloKInput.value ? eloKInput.value : 32)) || 32;
                const S1 = (winTeam === 1 ? 1 : 0), S2 = (winTeam === 2 ? 1 : 0);
                const d1 = K * (S1 - E1), d2 = K * (S2 - E2);
                team1.forEach(p => {
                    const mult = isPlacement(p.games) ? 2 : 1; p.score = Math.round(clamp(p.score + d1 * mult, -9999, 9999));
                    p.games = (p.games || 0) + 1; if (winTeam === 1) p.wins = (p.wins || 0) + 1; else p.losses = (p.losses || 0) + 1;
                });
                team2.forEach(p => {
                    const mult = isPlacement(p.games) ? 2 : 1; p.score = Math.round(clamp(p.score + d2 * mult, -9999, 9999));
                    p.games = (p.games || 0) + 1; if (winTeam === 2) p.wins = (p.wins || 0) + 1; else p.losses = (p.losses || 0) + 1;
                });
            } else {
                const delta = Math.round(Number(winBonusInput && winBonusInput.value ? winBonusInput.value : 10)) || 10;
                roster.forEach(p => {
                    const in1 = ids1.has(p.id), in2 = ids2.has(p.id); if (!in1 && !in2) return;
                    const mult = isPlacement(p.games) ? 2 : 1;
                    if (in1) p.score += (winTeam === 1 ? delta * mult : -delta * mult);
                    if (in2) p.score += (winTeam === 2 ? delta * mult : -delta * mult);
                    p.score = Math.round(clamp(p.score, -9999, 9999)); p.games = (p.games || 0) + 1;
                    if (in1) { if (winTeam === 1) p.wins = (p.wins || 0) + 1; else p.losses = (p.losses || 0) + 1; }
                    if (in2) { if (winTeam === 2) p.wins = (p.wins || 0) + 1; else p.losses = (p.losses || 0) + 1; }
                });
            }
            saveLocal(); renderRoster(); renderTeams();
        }

        /* ============ 환경설정 ============ */
        function initPrefs() {
            try { const v = localStorage.getItem(WIN_BONUS_KEY); if (v) winBonusInput.value = String(Math.round(+v || 10)); } catch { }
            if (winBonusInput) winBonusInput.addEventListener('change', () => { const v = Math.round(+winBonusInput.value || 10); winBonusInput.value = String(v); try { localStorage.setItem(WIN_BONUS_KEY, String(v)); } catch { } });
            try {
                const m = localStorage.getItem(MODE_KEY); if (m && scoringModeSel) scoringModeSel.value = m;
                const k = localStorage.getItem(ELO_K_KEY); if (k && eloKInput) eloKInput.value = String(Math.round(+k || 32));
            } catch { } toggleScoringControls();
            if (scoringModeSel) scoringModeSel.addEventListener('change', () => {
                try { localStorage.setItem(MODE_KEY, scoringModeSel.value); } catch { }
                toggleScoringControls();
            });
            if (eloKInput) eloKInput.addEventListener('change', () => { const v = Math.round(+eloKInput.value || 32); eloKInput.value = String(v); try { localStorage.setItem(ELO_K_KEY, String(v)); } catch { } });
        }

        function buildTeamsText() {
            // id → 이름 매핑
            const nameById = new Map(roster.map(p => [p.id, p.name]));
            const n1 = currentTeams.team1.map(id => nameById.get(id)).filter(Boolean);
            const n2 = currentTeams.team2.map(id => nameById.get(id)).filter(Boolean);

            const s1 = n1.length ? n1.join(', ') : '(비어있음)';
            const s2 = n2.length ? n2.join(', ') : '(비어있음)';
            return `1팀 ${s1}\n2팀 ${s2}`;
        }

        async function copyToClipboard(text) {
            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(text);
                    return true;
                }
            } catch (e) { /* fallback으로 진행 */ }

            // Fallback (구형 브라우저)
            const ta = document.createElement('textarea');
            ta.value = text;
            ta.style.position = 'fixed';
            ta.style.left = '-9999px';
            document.body.appendChild(ta);
            ta.select();
            const ok = document.execCommand('copy');
            document.body.removeChild(ta);
            return ok;
        }

        const btnCopy = document.getElementById('btnCopyTeamsText');
        if (btnCopy) {
            btnCopy.addEventListener('click', async () => {
                const text = buildTeamsText();
                const ok = await copyToClipboard(text);
                const old = btnCopy.textContent;
                btnCopy.textContent = ok ? '복사 완료!' : '복사 실패';
                setTimeout(() => { btnCopy.textContent = old; }, 1200);
            });
        }

        // 헤더 클릭으로 정렬 토글
        document.querySelectorAll('.rhead thead th.sortable').forEach(th => {
            th.addEventListener('click', () => {
                const key = th.getAttribute('data-sort');
                if (!key) return;
                if (rosterSortKey === key) {
                    rosterSortAsc = !rosterSortAsc;      // 같은 키면 방향 토글
                } else {
                    rosterSortKey = key;                 // 다른 키면 키 변경 + 기본 오름차순
                    rosterSortAsc = true;
                }
                renderRoster(); // 목록 갱신 + 헤더 화살표 갱신
            });
        });


        // ===== 초기화 =====
        loadLocal(); initPrefs();
        roster = roster.map(p => ({ ...p, mainLine: normLine(p.mainLine || 'A'), subLine: normLine(p.subLine || 'A') }));
        saveLocal();
        renderRoster(); renderTeams();
        toggleScoringControls();

    </script>
</body>

</html>
